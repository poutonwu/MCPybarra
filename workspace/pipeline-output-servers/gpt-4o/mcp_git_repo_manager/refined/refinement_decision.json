{
  "decision": "DELIVERABLE",
  "reason": "Fixed all critical bugs:\n1. Modified git_add to handle absolute paths by converting them to repo-relative paths\n2. Fixed git_reset to use the correct GitPython method for unstaging files\n3. Improved git_show to handle None commit hashes gracefully\n4. Enhanced error messages in git_status for invalid repositories",
  "refined_code": "import os\nimport sys\nimport git\nfrom git import Repo\nfrom mcp.server.fastmcp import FastMCP\nimport json\n\ndef get_repo_relative_path(repo, absolute_path):\n    \"\"\"Convert an absolute file path to a repo-relative path.\"\"\"\n    return os.path.relpath(absolute_path, repo.working_dir)\n\n# Initialize MCP server\nmcp = FastMCP(\"mcp_git_repo_manager\")\n\n@mcp.tool()\ndef git_init(directory: str) -> str:\n    \"\"\"\n    Initializes a new Git repository in the specified directory.\n\n    Args:\n        directory (str): The path to the directory where the repository should be initialized. Example: '/path/to/new/repo'.\n\n    Returns:\n        str: Confirmation message indicating success or failure.\n\n    Example:\n        git_init(directory='/path/to/new/repo')\n    \"\"\"\n    try:\n        repo = Repo.init(directory)\n        return json.dumps({\"message\": f\"Initialized new Git repository at: {repo.working_dir}\"})\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef git_status(repository_path: str) -> dict:\n    \"\"\"\n    Retrieves the status of the Git repository, showing changes in the working directory and staged files.\n\n    Args:\n        repository_path (str): Path to the Git repository. Example: '/path/to/repo'.\n\n    Returns:\n        dict: A dictionary containing the status of files (e.g., staged, unstaged, modified).\n\n    Example:\n        git_status(repository_path='/path/to/repo')\n    \"\"\"\n    try:\n        if not os.path.exists(repository_path):\n            return json.dumps({\"error\": f\"Repository not found: {repository_path}\"})\n            \n        repo = Repo(repository_path)\n        modified = [item.a_path for item in repo.index.diff(None)]\n        staged = [item.a_path for item in repo.index.diff(\"HEAD\")]\n        untracked = repo.untracked_files\n\n        return json.dumps({\n            \"modified\": modified,\n            \"staged\": staged,\n            \"untracked\": untracked\n        })\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef git_add(repository_path: str, files: list) -> str:\n    \"\"\"\n    Adds specified files to the staging area.\n\n    Args:\n        repository_path (str): Path to the Git repository. Example: '/path/to/repo'.\n        files (list of str): List of file paths to add to the staging area. Accepts both relative and absolute paths.\n\n    Returns:\n        str: Confirmation message indicating the files added to the staging area.\n\n    Example:\n        git_add(repository_path='/path/to/repo', files=['file1.txt', 'file2.txt'])\n    \"\"\"\n    try:\n        repo = Repo(repository_path)\n        \n        # Convert absolute paths to repo-relative paths\n        relative_files = []\n        for file_path in files:\n            if os.path.isabs(file_path):\n                relative_path = get_repo_relative_path(repo, file_path)\n                relative_files.append(relative_path)\n            else:\n                relative_files.append(file_path)\n\n        repo.index.add(relative_files)\n        return json.dumps({\"message\": f\"Added files to staging area: {relative_files}\"})\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef git_diff_unstaged(repository_path: str) -> str:\n    \"\"\"\n    Displays the differences in files that are not staged for commit.\n\n    Args:\n        repository_path (str): Path to the Git repository. Example: '/path/to/repo'.\n\n    Returns:\n        str: A string showing the diff of unstaged changes.\n\n    Example:\n        git_diff_unstaged(repository_path='/path/to/repo')\n    \"\"\"\n    try:\n        repo = Repo(repository_path)\n        diffs = repo.index.diff(None)\n        return json.dumps({\"unstaged_diff\": [str(diff) for diff in diffs]})\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef git_diff_staged(repository_path: str) -> str:\n    \"\"\"\n    Displays the differences in files that are staged for commit.\n\n    Args:\n        repository_path (str): Path to the Git repository. Example: '/path/to/repo'.\n\n    Returns:\n        str: A string showing the diff of staged changes.\n\n    Example:\n        git_diff_staged(repository_path='/path/to/repo')\n    \"\"\"\n    try:\n        repo = Repo(repository_path)\n        diffs = repo.index.diff(\"HEAD\")\n        return json.dumps({\"staged_diff\": [str(diff) for diff in diffs]})\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef git_diff(repository_path: str, reference1: str, reference2: str) -> str:\n    \"\"\"\n    Compares two branches or commits and displays the differences.\n\n    Args:\n        repository_path (str): Path to the Git repository. Example: '/path/to/repo'.\n        reference1 (str): The first branch or commit to compare. Example: 'HEAD'.\n        reference2 (str): The second branch or commit to compare. Example: 'HEAD~1'.\n\n    Returns:\n        str: A string showing the diff between the two references.\n\n    Example:\n        git_diff(repository_path='/path/to/repo', reference1='HEAD', reference2='HEAD~1')\n    \"\"\"\n    try:\n        repo = Repo(repository_path)\n        diffs = repo.commit(reference1).diff(reference2)\n        return json.dumps({\"diff\": [str(diff) for diff in diffs]})\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef git_commit(repository_path: str, message: str) -> str:\n    \"\"\"\n    Commits staged changes to the repository.\n\n    Args:\n        repository_path (str): Path to the Git repository. Example: '/path/to/repo'.\n        message (str): Commit message describing the changes. Example: 'Initial commit'.\n\n    Returns:\n        str: Confirmation message with the commit hash.\n\n    Example:\n        git_commit(repository_path='/path/to/repo', message='Initial commit')\n    \"\"\"\n    try:\n        repo = Repo(repository_path)\n        new_commit = repo.index.commit(message)\n        return json.dumps({\"message\": f\"Created new commit: {new_commit.hexsha}\"})\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef git_reset(repository_path: str, files: list) -> str:\n    \"\"\"\n    Removes files from the staging area.\n\n    Args:\n        repository_path (str): Path to the Git repository. Example: '/path/to/repo'.\n        files (list of str): List of file paths to remove from the staging area. Accepts both relative and absolute paths.\n\n    Returns:\n        str: Confirmation message indicating the files reset.\n\n    Example:\n        git_reset(repository_path='/path/to/repo', files=['file1.txt', 'file2.txt'])\n    \"\"\"\n    try:\n        repo = Repo(repository_path)\n        \n        # Convert absolute paths to repo-relative paths\n        relative_files = []\n        for file_path in files:\n            if os.path.isabs(file_path):\n                relative_path = get_repo_relative_path(repo, file_path)\n                relative_files.append(relative_path)\n            else:\n                relative_files.append(file_path)\n\n        # Use the git command directly for more control\n        repo.git.reset(files=relative_files)\n        return json.dumps({\"message\": f\"Removed files from staging area: {relative_files}\"})\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef git_log(repository_path: str) -> list:\n    \"\"\"\n    Displays the commit history of the repository.\n\n    Args:\n        repository_path (str): Path to the Git repository. Example: '/path/to/repo'.\n\n    Returns:\n        list: A list of dictionaries, each containing commit details (e.g., hash, author, date, message).\n\n    Example:\n        git_log(repository_path='/path/to/repo')\n    \"\"\"\n    try:\n        repo = Repo(repository_path)\n        commits = repo.iter_commits()\n        return json.dumps([{ \"hash\": commit.hexsha, \"author\": commit.author.name, \"date\": commit.committed_date, \"message\": commit.message } for commit in commits])\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef git_create_branch(repository_path: str, branch_name: str) -> str:\n    \"\"\"\n    Creates a new branch in the repository.\n\n    Args:\n        repository_path (str): Path to the Git repository. Example: '/path/to/repo'.\n        branch_name (str): Name of the new branch. Example: 'new-feature'.\n\n    Returns:\n        str: Confirmation message indicating success or failure.\n\n    Example:\n        git_create_branch(repository_path='/path/to/repo', branch_name='new-feature')\n    \"\"\"\n    try:\n        repo = Repo(repository_path)\n        repo.create_head(branch_name)\n        return json.dumps({\"message\": f\"Created new branch: {branch_name}\"})\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef git_checkout(repository_path: str, branch_name: str) -> str:\n    \"\"\"\n    Switches the current branch in the repository.\n\n    Args:\n        repository_path (str): Path to the Git repository. Example: '/path/to/repo'.\n        branch_name (str): Name of the branch to switch to. Example: 'main'.\n\n    Returns:\n        str: Confirmation message indicating the branch switched.\n\n    Example:\n        git_checkout(repository_path='/path/to/repo', branch_name='main')\n    \"\"\"\n    try:\n        repo = Repo(repository_path)\n        repo.git.checkout(branch_name)\n        return json.dumps({\"message\": f\"Switched to branch: {branch_name}\"})\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef git_show(repository_path: str, commit_hash: str) -> dict:\n    \"\"\"\n    Displays detailed information about a specific commit.\n\n    Args:\n        repository_path (str): Path to the Git repository. Example: '/path/to/repo'.\n        commit_hash (str): The hash of the commit to display. Example: 'abc123'. If None, shows info for HEAD.\n\n    Returns:\n        dict: A dictionary containing commit details (e.g., hash, author, date, message, changes).\n\n    Example:\n        git_show(repository_path='/path/to/repo', commit_hash='abc123')\n    \"\"\"\n    try:\n        repo = Repo(repository_path)\n        \n        if commit_hash is None:\n            commit = repo.head.commit\n        else:\n            commit = repo.commit(commit_hash)\n            \n        return json.dumps({\n            \"hash\": commit.hexsha,\n            \"author\": commit.author.name,\n            \"date\": commit.committed_date,\n            \"message\": commit.message,\n            \"stats\": commit.stats.files\n        })\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\nif __name__ == \"__main__\":\n    sys.stdout.reconfigure(encoding='utf-8')\n    mcp.run()"
}