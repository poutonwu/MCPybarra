{
  "decision": "DELIVERABLE",
  "reason": "Fixed critical bugs in SSH connection handling and error reporting. Improved session validation across all tools. Enhanced error messages to clearly indicate what went wrong in case of failures. Added proper handling of SSH connection states and improved reporting of dependency failures.",
  "refined_code": "import os\nimport json\nimport sys\nfrom paramiko import SSHClient, AutoAddPolicy, SSHException, AuthenticationException, Timeout\nfrom mcp.server.fastmcp import FastMCP\n\n# Initialize FastMCP server\nmcp = FastMCP(\"mcp_ssh_remote_manager\")\n\n# Dictionary to store active sessions\nactive_sessions = {}\n\n@mcp.tool()\ndef connect(hostname: str, username: str, password: str = None, private_key_path: str = None, port: int = 22) -> str:\n    \"\"\"\n    Establishes an SSH connection to a remote server.\n\n    Args:\n        hostname (str): The remote server's hostname or IP address.\n        username (str): The username for authentication.\n        password (str, optional): The password for authentication (used if private_key_path is not provided).\n        private_key_path (str, optional): The file path to the private key for key-based authentication.\n        port (int, optional): The port number for the SSH connection. Defaults to 22.\n\n    Returns:\n        str: A unique identifier for the established SSH session in JSON format.\n\n    Raises:\n        AuthenticationException: If authentication fails.\n        SSHException: If the connection fails.\n    \"\"\"\n    try:\n        # Input validation\n        if not hostname:\n            return json.dumps({\"error\": \"Invalid hostname\", \"details\": \"Hostname cannot be empty\"})\n        \n        if not username:\n            return json.dumps({\"error\": \"Invalid username\", \"details\": \"Username cannot be empty\"})\n        \n        if password is None and private_key_path is None:\n            return json.dumps({\"error\": \"Authentication failed\", \n                              \"details\": \"Either password or private key must be provided\"})\n\n        ssh = SSHClient()\n        ssh.set_missing_host_key_policy(AutoAddPolicy())\n\n        try:\n            if private_key_path:\n                ssh.connect(hostname, port=port, username=username, key_filename=private_key_path, timeout=10)\n            else:\n                ssh.connect(hostname, port=port, username=username, password=password, timeout=10)\n        except Timeout as e:\n            return json.dumps({\"error\": \"Connection timed out\", \n                             \"details\": f\"Unable to connect to {hostname}:{port} within timeout period ({str(e)})\"})\n        except SSHException as e:\n            # Handle specific SSH connection errors\n            if \"No route to host\" in str(e):\n                return json.dumps({\"error\": \"Network unreachable\", \n                                 \"details\": f\"Cannot reach {hostname}:{port} - No route to host\"})\n            elif \"Connection refused\" in str(e):\n                return json.dumps({\"error\": \"Connection refused\", \n                                 \"details\": f\"The SSH service on {hostname}:{port} is not available\"})\n            elif \"not found\" in str(e):  # Private key not found\n                return json.dumps({\"error\": \"Private key not found\", \n                                 \"details\": f\"The private key at {private_key_path} could not be loaded\"})\n            else:\n                return json.dumps({\"error\": \"SSH connection failed\", \n                                 \"details\": f\"Failed to establish SSH connection: {str(e)}\"})\n\n        session_id = f\"session_{len(active_sessions) + 1}\"\n        active_sessions[session_id] = ssh\n\n        return json.dumps({\"session_id\": session_id})\n\n    except AuthenticationException as e:\n        return json.dumps({\"error\": \"Authentication failed\", \"details\": str(e)})\n    except Exception as e:\n        return json.dumps({\"error\": \"Unexpected error\", \"details\": f\"An unexpected error occurred: {str(e)}\"})\n\n\n@mcp.tool()\ndef disconnect(session_id: str) -> str:\n    \"\"\"\n    Closes an active SSH session and releases its resources.\n\n    Args:\n        session_id (str): The unique identifier of the SSH session to be terminated.\n\n    Returns:\n        str: A confirmation message indicating the session was successfully terminated in JSON format.\n\n    Raises:\n        ValueError: If the session ID is invalid.\n    \"\"\"\n    try:\n        if session_id in active_sessions:\n            active_sessions[session_id].close()\n            del active_sessions[session_id]\n            return json.dumps({\"status\": \"Session terminated successfully\"})\n        else:\n            raise ValueError(\"Invalid session ID\")\n    except ValueError as e:\n        return json.dumps({\"error\": \"Invalid session ID\", \"details\": str(e)})\n\n\n@mcp.tool()\ndef list_sessions() -> str:\n    \"\"\"\n    Lists all currently active SSH sessions.\n\n    Returns:\n        str: A JSON string containing all active sessions.\n    \"\"\"\n    sessions = [{\"session_id\": session_id, \"hostname\": ssh.get_transport().getpeername()[0]} for session_id, ssh in active_sessions.items()]\n    return json.dumps({\"sessions\": sessions})\n\n\n@mcp.tool()\ndef execute(session_id: str, command: str, stdin: str = None, timeout: int = None) -> str:\n    \"\"\"\n    Executes a command on a specified SSH session.\n\n    Args:\n        session_id (str): The unique identifier of the SSH session.\n        command (str): The command to be executed on the remote server.\n        stdin (str, optional): Data to be passed to the command's standard input.\n        timeout (int, optional): The maximum time (in seconds) to wait for the command's execution.\n\n    Returns:\n        str: A JSON string containing the command's output, error, and exit code.\n\n    Raises:\n        ValueError: If the session ID is invalid.\n    \"\"\"\n    try:\n        if session_id not in active_sessions:\n            raise ValueError(f\"Invalid session ID: {session_id}. No active session found.\")\n            \n        transport = active_sessions[session_id].get_transport()\n        if not transport.is_active():\n            raise ValueError(f\"Session {session_id} exists but the underlying SSH connection is no longer active.\")\n            \n        channel = transport.open_session()\n        if timeout:\n            channel.settimeout(timeout)\n\n        channel.exec_command(command)\n        if stdin:\n            channel.sendall(stdin.encode())\n\n        stdout = channel.recv(1024).decode()\n        stderr = channel.recv_stderr(1024).decode()\n        exit_code = channel.recv_exit_status()\n\n        return json.dumps({\"stdout\": stdout, \"stderr\": stderr, \"exit_code\": exit_code})\n        \n    except ValueError as e:\n        return json.dumps({\"error\": \"Session error\", \"details\": str(e)})\n    except SSHException as e:\n        return json.dumps({\"error\": \"SSH error\", \"details\": f\"SSH operation failed: {str(e)}\"})\n\n\n@mcp.tool()\ndef upload(session_id: str, local_path: str, remote_path: str) -> str:\n    \"\"\"\n    Uploads a local file to a specified path on the remote server.\n\n    Args:\n        session_id (str): The unique identifier of the SSH session.\n        local_path (str): The file path of the local file to be uploaded.\n        remote_path (str): The destination file path on the remote server.\n\n    Returns:\n        str: A confirmation message indicating the file was successfully uploaded in JSON format.\n\n    Raises:\n        ValueError: If the session ID is invalid.\n    \"\"\"\n    try:\n        if session_id not in active_sessions:\n            raise ValueError(f\"Invalid session ID: {session_id}. No active session found.\")\n            \n        sftp = active_sessions[session_id].open_sftp()\n        sftp.put(local_path, remote_path)\n        sftp.close()\n        return json.dumps({\"status\": \"File uploaded successfully\"})\n        \n    except ValueError as e:\n        return json.dumps({\"error\": \"Session error\", \"details\": str(e)})\n    except FileNotFoundError as e:\n        return json.dumps({\"error\": \"File not found\", \"details\": f\"Local file not found: {str(e)}\"})\n    except PermissionError as e:\n        return json.dumps({\"error\": \"Permission denied\", \"details\": f\"Permission denied accessing file: {str(e)}\"})\n    except SSHException as e:\n        return json.dumps({\"error\": \"SSH error\", \"details\": f\"SSH operation failed: {str(e)}\"})\n\n\n@mcp.tool()\ndef download(session_id: str, remote_path: str, local_path: str) -> str:\n    \"\"\"\n    Downloads a file from the remote server to a specified local path.\n\n    Args:\n        session_id (str): The unique identifier of the SSH session.\n        remote_path (str): The file path on the remote server to be downloaded.\n        local_path (str): The destination file path on the local machine.\n\n    Returns:\n        str: A confirmation message indicating the file was successfully downloaded in JSON format.\n\n    Raises:\n        ValueError: If the session ID is invalid.\n    \"\"\"\n    try:\n        if session_id not in active_sessions:\n            raise ValueError(f\"Invalid session ID: {session_id}. No active session found.\")\n            \n        sftp = active_sessions[session_id].open_sftp()\n        sftp.get(remote_path, local_path)\n        sftp.close()\n        return json.dumps({\"status\": \"File downloaded successfully\"})\n        \n    except ValueError as e:\n        return json.dumps({\"error\": \"Session error\", \"details\": str(e)})\n    except FileNotFoundError as e:\n        return json.dumps({\"error\": \"File not found\", \"details\": f\"Remote file not found: {str(e)}\"})\n    except PermissionError as e:\n        return json.dumps({\"error\": \"Permission denied\", \"details\": f\"Permission denied accessing file: {str(e)}\"})\n    except SSHException as e:\n        return json.dumps({\"error\": \"SSH error\", \"details\": f\"SSH operation failed: {str(e)}\"})\n\n\nif __name__ == \"__main__\":\n    sys.stdout.reconfigure(encoding='utf-8')\n    mcp.run()"
}