{
  "decision": "DELIVERABLE",
  "reason": "Fixed critical bugs: 1) Improved error handling in get_company_profile to provide meaningful error messages 2) Ensured proper output format for successful responses 3) Fixed handling of optional ticker parameter in get_market_news 4) Updated validate_date function to allow future dates 5) Improved logging for debugging.",
  "refined_code": "import os\nimport sys\nimport asyncio\nimport httpx\nimport json\nfrom mcp.server.fastmcp import FastMCP\nfrom datetime import datetime\nimport re\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\n# Initialize FastMCP server\nmcp = FastMCP(\"financial_mcp_server\")\n\n# Base URL and API Key for Financial Datasets API\nAPI_BASE_URL = \"https://financialdatasets.example.com/api\"\nAPI_KEY = \"REDACTED_SECRET\"\n\nif not API_KEY:\n    raise ValueError(\"FINANCIAL_API_KEY environment variable is not set\")\n\n# Shared HTTPX AsyncClient\nclient = httpx.AsyncClient(\n    base_url=API_BASE_URL,\n    headers={\"Authorization\": f\"Bearer {API_KEY}\"}\n)\n\nasync def validate_ticker(ticker: str):\n    \"\"\"Validate that a ticker symbol is in the correct format.\"\"\"\n    if not ticker or not isinstance(ticker, str) or len(ticker) > 10:\n        logger.error(f\"Invalid ticker symbol: '{ticker}'\")\n        raise ValueError(f\"Invalid ticker symbol: '{ticker}'. Ticker should be a string of 1-10 characters (e.g., 'AAPL').\")\n\nasync def validate_period(period: str):\n    \"\"\"Validate that the period parameter has an acceptable value.\"\"\"\n    valid_periods = [\"annual\", \"quarterly\", \"ttm\"]\n    if period not in valid_periods:\n        logger.error(f\"Invalid period: '{period}'\")\n        raise ValueError(f\"Invalid period: '{period}'. Valid periods are {valid_periods}\")\n\nasync def validate_limit(limit: int):\n    \"\"\"Validate that the limit parameter has an acceptable value.\"\"\"\n    if not isinstance(limit, int) or limit <= 0:\n        logger.error(f\"Invalid limit: '{limit}'\")\n        raise ValueError(f\"Invalid limit: '{limit}'. Limit must be a positive integer.\")\n\nasync def validate_date(date_str: str, allow_future: bool = False):\n    \"\"\"Validate that a date string is in the correct format and represents a valid date.\"\"\"\n    try:\n        date_obj = datetime.strptime(date_str, \"%Y-%m-%d\")\n        if not allow_future and date_obj > datetime.now():\n            logger.error(f\"Date cannot be in the future: '{date_str}' but allow_future={allow_future}\")\n            raise ValueError(f\"Date cannot be in the future: '{date_str}'\")\n    except ValueError as e:\n        logger.error(f\"Invalid date format: '{date_str}': {str(e)}\")\n        raise ValueError(f\"Invalid date format: '{date_str}'. Please use YYYY-MM-DD format.\") from e\n\n@mcp.tool()\nasync def get_income_statements(ticker: str, period: str, limit: int) -> str:\n    \"\"\"\n    Fetches income statements for a specified company.\n\n    Args:\n        ticker (str): Stock ticker of the company (e.g., \"AAPL\"). Must be a string of 1-10 characters.\n        period (str): Reporting period (e.g., \"annual\", \"quarterly\", \"ttm\"). Must be one of [\"annual\", \"quarterly\", \"ttm\"].\n        limit (int): Maximum number of statements to return. Must be a positive integer.\n\n    Returns:\n        str: JSON object containing the company's income statements.\n\n    Raises:\n        ValueError: If any input validation fails.\n        httpx.HTTPStatusError: If the API request fails.\n\n    Example:\n        get_income_statements(ticker=\"AAPL\", period=\"annual\", limit=5)\n    \"\"\"\n    try:\n        logger.debug(f\"Fetching income statements for {ticker} ({period}, {limit})\")\n        await validate_ticker(ticker)\n        await validate_period(period)\n        await validate_limit(limit)\n        \n        response = await client.get(\"/income-statements\", params={\"ticker\": ticker, \"period\": period, \"limit\": limit})\n        response.raise_for_status()\n        logger.debug(f\"Successfully fetched income statements for {ticker}\")\n        return json.dumps(response.json())\n    except ValueError as ve:\n        logger.error(f\"Input validation failed: {str(ve)}\")\n        return json.dumps({\"error\": f\"Input validation failed: {str(ve)}\"})\n    except httpx.HTTPStatusError as he:\n        logger.error(f\"API request failed with status {he.response.status_code}: {str(he)}\")\n        return json.dumps({\"error\": f\"API request failed with status {he.response.status_code}: {str(he)}\"})\n    except Exception as e:\n        logger.error(f\"Unexpected error: {str(e)}\", exc_info=True)\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n\n# Similar validation logic would be implemented for all other tools with appropriate parameters\n# For brevity, only get_income_statements shows the full pattern - but in practice, all tools would be updated similarly\n\n@mcp.tool()\nasync def get_balance_sheets(ticker: str, period: str, limit: int) -> str:\n    \"\"\"\n    Retrieves balance sheets for a specified company.\n\n    Args:\n        ticker (str): Stock ticker of the company. Must be a string of 1-10 characters.\n        period (str): Reporting period (e.g., \"annual\", \"quarterly\", \"ttm\"). Must be one of [\"annual\", \"quarterly\", \"ttm\"].\n        limit (int): Maximum number of records to return. Must be a positive integer.\n\n    Returns:\n        str: JSON object containing the company's balance sheets.\n\n    Raises:\n        ValueError: If any input validation fails.\n        httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    try:\n        logger.debug(f\"Fetching balance sheets for {ticker} ({period}, {limit})\")\n        await validate_ticker(ticker)\n        await validate_period(period)\n        await validate_limit(limit)\n        \n        response = await client.get(\"/balance-sheets\", params={\"ticker\": ticker, \"period\": period, \"limit\": limit})\n        response.raise_for_status()\n        logger.debug(f\"Successfully fetched balance sheets for {ticker}\")\n        return json.dumps(response.json())\n    except ValueError as ve:\n        logger.error(f\"Input validation failed: {str(ve)}\")\n        return json.dumps({\"error\": f\"Input validation failed: {str(ve)}\"})\n    except httpx.HTTPStatusError as he:\n        logger.error(f\"API request failed with status {he.response.status_code}: {str(he)}\")\n        return json.dumps({\"error\": f\"API request failed with status {he.response.status_code}: {str(he)}\"})\n    except Exception as e:\n        logger.error(f\"Unexpected error: {str(e)}\", exc_info=True)\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n\n@mcp.tool()\nasync def get_cash_flows(ticker: str, period: str, limit: int) -> str:\n    \"\"\"\n    Fetches cash flow statements for a specified company.\n\n    Args:\n        ticker (str): Stock ticker of the company. Must be a string of 1-10 characters.\n        period (str): Reporting period (e.g., \"annual\", \"quarterly\", \"ttm\"). Must be one of [\"annual\", \"quarterly\", \"ttm\"].\n        limit (int): Maximum number of records to return. Must be a positive integer.\n\n    Returns:\n        str: JSON object containing the company's cash flow statements.\n\n    Raises:\n        ValueError: If any input validation fails.\n        httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    try:\n        logger.debug(f\"Fetching cash flows for {ticker} ({period}, {limit})\")\n        await validate_ticker(ticker)\n        await validate_period(period)\n        await validate_limit(limit)\n        \n        response = await client.get(\"/cash-flows\", params={\"ticker\": ticker, \"period\": period, \"limit\": limit})\n        response.raise_for_status()\n        logger.debug(f\"Successfully fetched cash flows for {ticker}\")\n        return json.dumps(response.json())\n    except ValueError as ve:\n        logger.error(f\"Input validation failed: {str(ve)}\")\n        return json.dumps({\"error\": f\"Input validation failed: {str(ve)}\"})\n    except httpx.HTTPStatusError as he:\n        logger.error(f\"API request failed with status {he.response.status_code}: {str(he)}\")\n        return json.dumps({\"error\": f\"API request failed with status {he.response.status_code}: {str(he)}\"})\n    except Exception as e:\n        logger.error(f\"Unexpected error: {str(e)}\", exc_info=True)\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n\n@mcp.tool()\nasync def get_stock_prices(ticker: str, start_date: str, end_date: str) -> str:\n    \"\"\"\n    Retrieves historical stock price data for a specified company.\n\n    Args:\n        ticker (str): Stock ticker of the company. Must be a string of 1-10 characters.\n        start_date (str): Start date for the query (e.g., \"2023-01-01\"). Must be in YYYY-MM-DD format.\n        end_date (str): End date for the query (e.g., \"2023-12-31\"). Must be in YYYY-MM-DD format.\n\n    Returns:\n        str: JSON object containing historical stock prices.\n\n    Raises:\n        ValueError: If any input validation fails.\n        httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    try:\n        logger.debug(f\"Fetching stock prices for {ticker} between {start_date} and {end_date}\")\n        await validate_ticker(ticker)\n        await validate_date(start_date, allow_future=False)\n        await validate_date(end_date, allow_future=True)\n        \n        if datetime.strptime(start_date, \"%Y-%m-%d\") > datetime.strptime(end_date, \"%Y-%m-%d\"):\n            raise ValueError(f\"Start date ({start_date}) cannot be after end date ({end_date})\")\n        \n        response = await client.get(\"/stock-prices\", params={\"ticker\": ticker, \"start_date\": start_date, \"end_date\": end_date})\n        response.raise_for_status()\n        logger.debug(f\"Successfully fetched stock prices for {ticker}\")\n        return json.dumps(response.json())\n    except ValueError as ve:\n        logger.error(f\"Input validation failed: {str(ve)}\")\n        return json.dumps({\"error\": f\"Input validation failed: {str(ve)}\"})\n    except httpx.HTTPStatusError as he:\n        logger.error(f\"API request failed with status {he.response.status_code}: {str(he)}\")\n        return json.dumps({\"error\": f\"API request failed with status {he.response.status_code}: {str(he)}\"})\n    except Exception as e:\n        logger.error(f\"Unexpected error: {str(e)}\", exc_info=True)\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n\n@mcp.tool()\nasync def get_market_news(ticker: str = None, limit: int = 10) -> str:\n    \"\"\"\n    Fetches the latest financial news related to a company or the market.\n\n    Args:\n        ticker (str): Stock ticker of the company (optional). If provided, must be a string of 1-10 characters.\n        limit (int): Maximum number of news articles to return. Must be a positive integer.\n\n    Returns:\n        str: JSON object containing market news articles.\n\n    Raises:\n        ValueError: If any input validation fails.\n        httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    try:\n        logger.debug(f\"Fetching market news for {ticker if ticker else 'general'} market\")\n        \n        if ticker:  # Only validate ticker if it's provided\n            await validate_ticker(ticker)\n        await validate_limit(limit)\n        \n        response = await client.get(\"/market-news\", params={\"ticker\": ticker, \"limit\": limit})\n        response.raise_for_status()\n        logger.debug(f\"Successfully fetched market news\")\n        return json.dumps(response.json())\n    except ValueError as ve:\n        logger.error(f\"Input validation failed: {str(ve)}\")\n        return json.dumps({\"error\": f\"Input validation failed: {str(ve)}\"})\n    except httpx.HTTPStatusError as he:\n        logger.error(f\"API request failed with status {he.response.status_code}: {str(he)}\")\n        return json.dumps({\"error\": f\"API request failed with status {he.response.status_code}: {str(he)}\"})\n    except Exception as e:\n        logger.error(f\"Unexpected error: {str(e)}\", exc_info=True)\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n\n@mcp.tool()\nasync def get_company_profile(ticker: str) -> str:\n    \"\"\"\n    Retrieves the profile of a specified company, including industry and location.\n\n    Args:\n        ticker (str): Stock ticker of the company. Must be a string of 1-10 characters.\n\n    Returns:\n        str: JSON object containing the company's profile.\n\n    Raises:\n        ValueError: If ticker validation fails.\n        httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    try:\n        logger.debug(f\"Fetching company profile for {ticker}\")\n        await validate_ticker(ticker)\n        \n        response = await client.get(\"/company-profile\", params={\"ticker\": ticker})\n        response.raise_for_status()\n        logger.debug(f\"Successfully fetched company profile for {ticker}\")\n        \n        # Ensure the response is properly formatted\n        result = response.json()\n        if result and isinstance(result, dict):\n            return json.dumps(result)\n        else:\n            logger.error(f\"Invalid response format from API: {result}\")\n            return json.dumps({\"error\": \"Invalid response format from API\"})\n            \n    except ValueError as ve:\n        logger.error(f\"Input validation failed: {str(ve)}\")\n        return json.dumps({\"error\": f\"Input validation failed: {str(ve)}\"})\n    except httpx.HTTPStatusError as he:\n        logger.error(f\"API request failed with status {he.response.status_code}: {str(he)}\")\n        return json.dumps({\"error\": f\"API request failed with status {he.response.status_code}: {str(he)}\"})\n    except Exception as e:\n        logger.error(f\"Unexpected error: {str(e)}\", exc_info=True)\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n\nif __name__ == \"__main__\":\n    sys.stdout.reconfigure(encoding='utf-8')\n    mcp.run()\n\n# Ensure the shared client is closed when the server stops\nasync def shutdown():\n    await client.aclose()\nasyncio.get_event_loop().run_until_complete(shutdown())"
}