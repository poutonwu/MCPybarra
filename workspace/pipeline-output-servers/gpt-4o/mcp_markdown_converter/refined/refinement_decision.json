{
  "decision": "NEEDS_REFINEMENT",
  "reason": "Fixed bugs #1, #3, and #4. Bug #2 requires additional work to handle JSON-encoded paths correctly during schema validation.",
  "refined_code": "import sys\nimport os\nimport httpx\nimport base64\nfrom markitdown import MarkItDown\nfrom mcp.server.fastmcp import FastMCP\n\n# Initialize FastMCP Server\nmcp = FastMCP(\"mcp_markdown_converter\")\n\n@mcp.tool()\ndef convert_to_markdown(source: str, source_type: str) -> str:\n    \"\"\"\n    Converts various content formats (HTTP/HTTPS webpages, local files, and data URIs) into structured Markdown format.\n\n    Args:\n        source (str): The source to convert to Markdown. This can be a URL (HTTP or HTTPS), a local file path, or a data URI.\n            Example: \"https://example.com\" or \"/path/to/local/file.txt\" or \"data:text/plain;base64,SGVsbG8gd29ybGQ=\"\n        source_type (str): Specifies the type of the source (\"url\", \"file\", or \"data_uri\").\n            Example: \"url\"\n\n    Returns:\n        str: A string containing the Markdown representation of the input content. This will retain structural elements like headings, lists, links, and tables.\n\n    Raises:\n        ValueError: If the source_type is not one of \"url\", \"file\", or \"data_uri\".\n        httpx.HTTPStatusError: If the HTTP request fails for a URL source.\n        FileNotFoundError: If the local file does not exist.\n        Exception: For general errors during conversion.\n\n    Example:\n        convert_to_markdown(\"https://example.com\", \"url\")\n    \"\"\"\n    try:\n        md = MarkItDown()\n\n        if source_type == \"url\":\n            # Fetch content from URL\n            response = httpx.get(source)\n            response.raise_for_status()\n            content = response.text\n\n        elif source_type == \"file\":\n            # Read content from local file\n            if not os.path.exists(source):\n                raise FileNotFoundError(f\"File not found: {source}\")\n\n            # Detect binary files\n            try:\n                with open(source, \"r\", encoding=\"utf-8-sig\") as file:\n                    content = file.read()\n            except UnicodeDecodeError:\n                raise Exception(f\"Binary files are not supported: {source}. Please provide text-based files only.\")\n\n        elif source_type == \"data_uri\":\n            # Decode content from data URI\n            if not source.startswith(\"data:\"):\n                raise ValueError(\"Invalid data URI format.\")\n            comma_index = source.find(\",\")\n            if comma_index == -1:\n                raise ValueError(\"Invalid data URI format.\")\n            base64_content = source[comma_index + 1:]\n            content = base64.b64decode(base64_content).decode(\"utf-8\")\n\n        else:\n            raise ValueError(f\"Unsupported source_type: {source_type}\")\n\n        # Convert content to Markdown\n        result = md.convert(content)\n        return result\n\n    except httpx.HTTPStatusError as e:\n        # Ensure we have proper request and response objects in the exception\n        if not hasattr(e, 'request') or not hasattr(e, 'response'):\n            raise httpx.HTTPStatusError(\n                message=str(e),\n                request=e.request if hasattr(e, 'request') else httpx.Request(\"GET\", source),\n                response=e.response if hasattr(e, 'response') else response if 'response' in locals() else None\n            ) from e\n        raise\n    except FileNotFoundError as e:\n        raise FileNotFoundError(f\"File error: {str(e)}\") from e\n    except Exception as e:\n        raise Exception(f\"An error occurred: {str(e)}\") from e\n\nif __name__ == \"__main__\":\n    sys.stdout.reconfigure(encoding='utf-8')\n    mcp.run()"
}