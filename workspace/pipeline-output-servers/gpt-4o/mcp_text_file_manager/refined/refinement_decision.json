{
  "decision": "DELIVERABLE",
  "reason": "Fixed critical issues with path resolution by implementing a path resolver that handles $temp_dir placeholder and ensuring directories exist before file operations. Added comprehensive error handling and improved input validation across all tools.",
  "refined_code": "import os\nimport json\nimport hashlib\nfrom itertools import islice\nfrom mcp.server.fastmcp import FastMCP\n\ndef resolve_path(file_path: str) -> str:\n    \"\"\"\n    Resolve placeholder variables in file paths.\n    \n    Currently supports:\n    - $temp_dir: System's temporary directory\n    - $cwd: Current working directory\n    \"\"\"\n    if not file_path:\n        return file_path\n        \n    # Replace $temp_dir with actual temporary directory\n    if file_path.startswith(\"$temp_dir\"):\n        temp_dir = os.getenv('TEMP', os.getenv('TMPDIR', '/tmp'))\n        return file_path.replace(\"$temp_dir\", temp_dir, 1)\n        \n    # Replace $cwd with current working directory\n    if file_path.startswith(\"$cwd\"):\n        cwd = os.getcwd()\n        return file_path.replace(\"$cwd\", cwd, 1)\n        \n    return file_path\n\ndef ensure_directory_exists(file_path: str):\n    \"\"\"\n    Ensure that the directory for the given file path exists.\n    If not, create it.\n    \"\"\"\n    directory = os.path.dirname(resolve_path(file_path))\n    if directory and not os.path.exists(directory):\n        os.makedirs(directory)\n\n@mcp.tool()\ndef get_text_file_contents(file_path: str, start_line: int = None, end_line: int = None) -> str:\n    \"\"\"\n    Reads the content of a text file within a specified line range and returns the file's hash for concurrency control.\n\n    Args:\n        file_path (str): Path to the text file.\n        start_line (int, optional): The starting line number (inclusive). Defaults to None.\n        end_line (int, optional): The ending line number (inclusive). Defaults to None.\n\n    Returns:\n        str: JSON string containing 'content' and 'hash'.\n\n    Example:\n        get_text_file_contents(\"example.txt\", start_line=1, end_line=5)\n    \"\"\"\n    try:\n        resolved_path = resolve_path(file_path)\n        \n        if not os.path.exists(resolved_path):\n            return json.dumps({\"error\": f\"File does not exist: {file_path}\"})\n\n        with open(resolved_path, \"r\", encoding=\"utf-8\") as file:\n            if start_line is not None and end_line is not None:\n                lines = list(islice(file, start_line - 1, end_line))\n            else:\n                lines = file.readlines()\n                \n            content = \"\".join(lines)\n\n        with open(resolved_path, \"rb\") as file:\n            file_hash = hashlib.sha256(file.read()).hexdigest()\n\n        return json.dumps({\"content\": content, \"hash\": file_hash})\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef create_text_file(file_path: str, content: str) -> str:\n    \"\"\"\n    Creates a new text file and writes the provided content to it.\n\n    Args:\n        file_path (str): Path where the new file should be created.\n        content (str): The content to write to the new file.\n\n    Returns:\n        str: Success message.\n\n    Example:\n        create_text_file(\"new_file.txt\", \"Hello, World!\")\n    \"\"\"\n    try:\n        resolved_path = resolve_path(file_path)\n        ensure_directory_exists(resolved_path)\n        \n        with open(resolved_path, \"w\", encoding=\"utf-8\") as file:\n            file.write(content)\n        return json.dumps({\"message\": \"File created successfully.\"})\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef append_text_file_contents(file_path: str, content: str) -> str:\n    \"\"\"\n    Appends content to an existing text file.\n\n    Args:\n        file_path (str): Path to the existing text file.\n        content (str): The content to append to the file.\n\n    Returns:\n        str: Success message.\n\n    Example:\n        append_text_file_contents(\"example.txt\", \"Additional text.\")\n    \"\"\"\n    try:\n        resolved_path = resolve_path(file_path)\n        ensure_directory_exists(resolved_path)\n        \n        with open(resolved_path, \"a\", encoding=\"utf-8\") as file:\n            file.write(content + \"\\n\")\n        return json.dumps({\"message\": \"Content appended successfully.\"})\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef delete_text_file_contents(file_path: str, start_line: int, end_line: int) -> str:\n    \"\"\"\n    Deletes content within a specified line range in a text file.\n\n    Args:\n        file_path (str): Path to the text file.\n        start_line (int): The starting line number (inclusive).\n        end_line (int): The ending line number (inclusive).\n\n    Returns:\n        str: Success message.\n\n    Example:\n        delete_text_file_contents(\"example.txt\", start_line=2, end_line=4)\n    \"\"\"\n    try:\n        resolved_path = resolve_path(file_path)\n        \n        if not os.path.exists(resolved_path):\n            return json.dumps({\"error\": f\"File does not exist: {file_path}\"})\n\n        with open(resolved_path, \"r\", encoding=\"utf-8\") as file:\n            lines = file.readlines()\n\n        if start_line < 1 or end_line > len(lines) or start_line > end_line:\n            return json.dumps({\"error\": f\"Invalid line range: start_line={start_line}, end_line={end_line}. File has {len(lines)} lines.\"})\n\n        with open(resolved_path, \"w\", encoding=\"utf-8\") as file:\n            file.writelines(lines[:start_line - 1] + lines[end_line:])\n\n        return json.dumps({\"message\": \"Specified lines deleted successfully.\"})\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef insert_text_file_contents(file_path: str, line_number: int, content: str) -> str:\n    \"\"\"\n    Inserts content at a specified position in a text file.\n\n    Args:\n        file_path (str): Path to the text file.\n        line_number (int): The line number before which the content will be inserted.\n        content (str): The content to insert into the file.\n\n    Returns:\n        str: Success message.\n\n    Example:\n        insert_text_file_contents(\"example.txt\", line_number=3, content=\"Inserted text.\")\n    \"\"\"\n    try:\n        resolved_path = resolve_path(file_path)\n        ensure_directory_exists(resolved_path)\n        \n        with open(resolved_path, \"r\", encoding=\"utf-8\") as file:\n            lines = file.readlines()\n\n        if line_number < 1 or line_number > len(lines) + 1:\n            return json.dumps({\"error\": f\"Invalid line number: {line_number}. File has {len(lines)} lines.\"})\n\n        lines.insert(line_number - 1, content + \"\\n\")\n\n        with open(resolved_path, \"w\", encoding=\"utf-8\") as file:\n            file.writelines(lines)\n\n        return json.dumps({\"message\": \"Content inserted successfully.\"})\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef patch_text_file_contents(file_path: str, patch_data: list, expected_hash: str) -> str:\n    \"\"\"\n    Applies precise edits to a text file based on provided changes. Validates the file hash to avoid concurrency conflicts.\n\n    Args:\n        file_path (str): Path to the text file.\n        patch_data (list of dict): A list of changes, each specifying:\n            - start_line (int): Start line for the patch.\n            - end_line (int): End line for the patch.\n            - new_content (str): New content to replace the specified range.\n        expected_hash (str): Expected SHA256 hash of the file to confirm no concurrent modifications.\n\n    Returns:\n        str: Success message if the patch is applied successfully, or error message if the hash does not match.\n\n    Example:\n        patch_text_file_contents(\n            \"example.txt\",\n            patch_data=[{\"start_line\": 2, \"end_line\": 3, \"new_content\": \"Patched content.\"}],\n            expected_hash=\"abc123\"\n        )\n    \"\"\"\n    try:\n        resolved_path = resolve_path(file_path)\n        \n        if not os.path.exists(resolved_path):\n            return json.dumps({\"error\": f\"File does not exist: {file_path}\"})\n\n        with open(resolved_path, \"rb\") as file:\n            current_hash = hashlib.sha256(file.read()).hexdigest()\n\n        if expected_hash and current_hash != expected_hash:\n            return json.dumps({\"error\": f\"File hash mismatch. Patch aborted. Current hash: {current_hash}\"})\n\n        with open(resolved_path, \"r\", encoding=\"utf-8\") as file:\n            lines = file.readlines()\n\n        for patch in patch_data:\n            start_line = patch[\"start_line\"]\n            end_line = patch[\"end_line\"]\n            new_content = patch[\"new_content\"]\n            \n            if start_line < 1 or end_line < start_line:\n                return json.dumps({\"error\": f\"Invalid line range: start_line={start_line}, end_line={end_line}. Lines must be >= 1 and end_line >= start_line\"})\n\n            start_idx = max(0, start_line - 1)\n            end_idx = min(len(lines), end_line)\n            \n            lines[start_idx:end_idx] = [new_content + \"\\n\"]\n\n        with open(resolved_path, \"w\", encoding=\"utf-8\") as file:\n            file.writelines(lines)\n\n        with open(resolved_path, \"rb\") as file:\n            new_hash = hashlib.sha256(file.read()).hexdigest()\n\n        return json.dumps({\"message\": \"Patch applied successfully.\", \"new_hash\": new_hash})\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\nif __name__ == \"__main__\":\n    import sys\n    sys.stdout.reconfigure(encoding=\"utf-8\")\n    mcp.run(transport=\"stdio\")"
}