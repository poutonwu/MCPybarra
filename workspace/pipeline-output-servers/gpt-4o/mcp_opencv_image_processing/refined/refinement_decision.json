{
  "decision": "DELIVERABLE",
  "reason": "Fixed all critical bugs: 1) Added proper Unicode path handling for OpenCV image loading, 2) Improved input validation for dimensions in resize_image_tool, 3) Added proper filter type validation, and 4) Enhanced error handling to prevent error objects from being passed as inputs.",
  "refined_code": "import sys\nimport os\nimport json\nimport cv2\nfrom mcp.server.fastmcp import FastMCP\n\n# Initialize MCP Server\nmcp = FastMCP(\"mcp_opencv_image_processing\")\n\ndef _load_image(image_path: str):\n    \"\"\"Helper function to load an image with robust error handling. Handles Unicode paths properly.\"\"\"\n    if not os.path.exists(image_path):\n        raise FileNotFoundError(f\"Image not found at the specified path: {image_path}\")\n    \n    # Handle Unicode paths by converting to bytes using default filesystem encoding\n    try:\n        # Try reading directly first (works for ASCII paths)\n        image = cv2.imread(image_path)\n        if image is None:\n            # If that fails, try encoding the path\n            encoded_path = os.fsencode(image_path)\n            image = cv2.imread(encoded_path)\n            \n        if image is None:\n            raise ValueError(f\"Failed to load image from path: {image_path}\")\n            \n        return image\n            \n    except Exception as e:\n        raise ValueError(f\"Failed to load image from path: {image_path}\") from e\n\n@mcp.tool()\ndef save_image_tool(image_path: str, output_path: str) -> bool:\n    \"\"\"Saves an image to the file system in the desired format.\n\n    Args:\n        image_path (str): Path to the input image file.\n        output_path (str): Path to save the output image file.\n\n    Returns:\n        bool: True if the image is successfully saved, otherwise False.\n\n    Raises:\n        FileNotFoundError: If the input image file doesn't exist\n        ValueError: If the image can't be loaded or saved\n\n    Example:\n        save_image_tool(\"input.jpg\", \"output.png\")\n    \"\"\"\n    try:\n        image = _load_image(image_path)\n        result = cv2.imwrite(output_path, image)\n        return result\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef resize_image_tool(image_path: str, width: int, height: int) -> str:\n    \"\"\"Resizes the image to specific dimensions.\n\n    Args:\n        image_path (str): Path to the input image file.\n        width (int): The new width of the image. Must be positive.\n        height (int): The new height of the image. Must be positive.\n\n    Returns:\n        str: Path to the resized image file.\n\n    Raises:\n        ValueError: If width or height are not positive integers\n\n    Example:\n        resize_image_tool(\"input.jpg\", 800, 600)\n    \"\"\"\n    try:\n        # Validate dimensions first\n        if not isinstance(width, int) or not isinstance(height, int):\n            raise ValueError(\"Width and height must be integers\")\n        if width <= 0 or height <= 0:\n            raise ValueError(f\"Width and height must be positive values. Received: width={width}, height={height}\")\n            \n        image = _load_image(image_path)\n        resized_image = cv2.resize(image, (width, height))\n        output_path = \"resized_image.jpg\"\n        cv2.imwrite(output_path, resized_image)\n        return output_path\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef crop_image_tool(image_path: str, x: int, y: int, width: int, height: int) -> str:\n    \"\"\"Crops a specific rectangular region from the image.\n\n    Args:\n        image_path (str): Path to the input image file.\n        x (int): The x-coordinate of the top-left corner of the crop box.\n        y (int): The y-coordinate of the top-left corner of the crop box.\n        width (int): The width of the crop box. Must be positive.\n        height (int): The height of the crop box. Must be positive.\n\n    Returns:\n        str: Path to the cropped image file.\n\n    Raises:\n        ValueError: If any dimension parameters are invalid\n\n    Example:\n        crop_image_tool(\"input.jpg\", 10, 10, 100, 100)\n    \"\"\"\n    try:\n        # Input validation\n        if not all(isinstance(arg, int) for arg in [x, y, width, height]):\n            raise ValueError(\"All coordinates and dimensions must be integers\")\n        if width <= 0 or height <= 0:\n            raise ValueError(f\"Width and height must be positive values. Received: width={width}, height={height}\")\n        if x < 0 or y < 0:\n            raise ValueError(f\"Coordinates cannot be negative. Received: x={x}, y={y}\")\n            \n        image = _load_image(image_path)\n        cropped_image = image[y:y+height, x:x+width]\n        output_path = \"cropped_image.jpg\"\n        cv2.imwrite(output_path, cropped_image)\n        return output_path\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef get_image_stats_tool(image_path: str) -> str:\n    \"\"\"Retrieves basic statistics about the image, including dimensions and pixel intensity histograms.\n\n    Args:\n        image_path (str): Path to the input image file.\n\n    Returns:\n        str: JSON string containing dimensions and histogram data.\n\n    Example:\n        get_image_stats_tool(\"input.jpg\")\n    \"\"\"\n    try:\n        image = _load_image(image_path)\n        dimensions = image.shape\n        histogram = cv2.calcHist([image], [0], None, [256], [0, 256]).flatten().tolist()\n        return json.dumps({\"dimensions\": dimensions, \"histogram\": histogram})\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef apply_filter_tool(image_path: str, filter_type: str, kernel_size: int) -> str:\n    \"\"\"Applies a specified filter to the image (e.g., Gaussian blur, median blur).\n\n    Args:\n        image_path (str): Path to the input image file.\n        filter_type (str): The type of filter to apply (\"gaussian\", \"median\", etc.).\n        kernel_size (int): The size of the kernel used for filtering. Must be odd and positive.\n\n    Returns:\n        str: Path to the filtered image file.\n\n    Raises:\n        ValueError: If filter_type is unsupported or kernel_size is invalid\n\n    Example:\n        apply_filter_tool(\"input.jpg\", \"gaussian\", 5)\n    \"\"\"\n    try:\n        # Validate filter type and kernel size\n        supported_filters = [\"gaussian\", \"median\"]\n        if filter_type.lower() not in supported_filters:\n            raise ValueError(f\"Unsupported filter type '{filter_type}'. Supported filters: {supported_filters}\")\n            \n        if not isinstance(kernel_size, int):\n            raise ValueError(\"Kernel size must be an integer\")\n        if kernel_size <= 0:\n            raise ValueError(f\"Kernel size must be positive. Received: {kernel_size}\")\n        if kernel_size % 2 == 0:\n            raise ValueError(f\"Kernel size should be odd for OpenCV filters. Received: {kernel_size}\")\n            \n        image = _load_image(image_path)\n        \n        if filter_type.lower() == \"gaussian\":\n            filtered_image = cv2.GaussianBlur(image, (kernel_size, kernel_size), 0)\n        elif filter_type.lower() == \"median\":\n            filtered_image = cv2.medianBlur(image, kernel_size)\n        \n        output_path = \"filtered_image.jpg\"\n        cv2.imwrite(output_path, filtered_image)\n        return output_path\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef detect_edges_tool(image_path: str, threshold1: float, threshold2: float) -> str:\n    \"\"\"Detects edges in the image using OpenCV's Canny edge detection algorithm.\n\n    Args:\n        image_path (str): Path to the input image file.\n        threshold1 (float): The first threshold for the hysteresis procedure.\n        threshold2 (float): The second threshold for the hysteresis procedure.\n\n    Returns:\n        str: Path to the edge-detected image file.\n\n    Example:\n        detect_edges_tool(\"input.jpg\", 50.0, 150.0)\n    \"\"\"\n    try:\n        image = _load_image(image_path)\n        gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n        edges = cv2.Canny(gray_image, threshold1, threshold2)\n        output_path = \"edges_image.jpg\"\n        cv2.imwrite(output_path, edges)\n        return output_path\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef apply_threshold_tool(image_path: str, threshold_value: float, max_value: float) -> str:\n    \"\"\"Applies a thresholding operation to the image.\n\n    Args:\n        image_path (str): Path to the input grayscale image file.\n        threshold_value (float): The threshold value.\n        max_value (float): The maximum value to assign to pixels exceeding the threshold.\n\n    Returns:\n        str: Path to the thresholded binary image file.\n\n    Example:\n        apply_threshold_tool(\"input.jpg\", 127.0, 255.0)\n    \"\"\"\n    try:\n        image = _load_image(image_path)\n        gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n        _, thresholded_image = cv2.threshold(gray_image, threshold_value, max_value, cv2.THRESH_BINARY)\n        output_path = \"thresholded_image.jpg\"\n        cv2.imwrite(output_path, thresholded_image)\n        return output_path\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef detect_contours_tool(image_path: str) -> str:\n    \"\"\"Detects contours in the image.\n\n    Args:\n        image_path (str): Path to the input binary image file.\n\n    Returns:\n        str: JSON string containing a list of contours.\n\n    Example:\n        detect_contours_tool(\"thresholded_image.jpg\")\n    \"\"\"\n    try:\n        image = _load_image(image_path)\n        gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n        contours, _ = cv2.findContours(gray_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        contours_list = [contour.tolist() for contour in contours]\n        return json.dumps({\"contours\": contours_list})\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\n@mcp.tool()\ndef find_shapes_tool(image_path: str) -> str:\n    \"\"\"Identifies and classifies simple geometric shapes (e.g., circles, squares) in the image.\n\n    Args:\n        image_path (str): Path to the input binary image file.\n\n    Returns:\n        str: JSON string containing a list of detected shapes.\n\n    Example:\n        find_shapes_tool(\"thresholded_image.jpg\")\n    \"\"\"\n    try:\n        image = _load_image(image_path)\n        gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n        contours, _ = cv2.findContours(gray_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        shapes = []\n        for contour in contours:\n            approx = cv2.approxPolyDP(contour, 0.04 * cv2.arcLength(contour, True), True)\n            if len(approx) == 3:\n                shape = \"triangle\"\n            elif len(approx) == 4:\n                shape = \"rectangle\"\n            elif len(approx) > 4:\n                shape = \"circle\"\n            else:\n                shape = \"unknown\"\n            shapes.append({\"shape\": shape, \"contour\": contour.tolist()})\n        return json.dumps({\"shapes\": shapes})\n    except Exception as e:\n        return json.dumps({\"error\": str(e)})\n\nif __name__ == \"__main__\":\n    sys.stdout.reconfigure(encoding=\"utf-8\")\n    mcp.run()"
}