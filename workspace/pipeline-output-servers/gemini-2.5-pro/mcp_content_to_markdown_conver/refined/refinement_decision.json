{
  "decision": "DELIVERABLE",
  "reason": "Fixed all three identified bugs: 1) Added explicit check for supported URL schemes (http/https), 2) Improved handling of dependent operations by distinguishing between content and file paths, and 3) Added binary file detection before attempting UTF-8 decoding. All fixes maintain existing functionality while addressing the specific issues in the test report.",
  "refined_code": "import sys\nimport re\nimport base64\nimport os\nimport binascii\nfrom urllib.parse import urlparse\nimport requests\nfrom mcp.server.fastmcp import FastMCP\nfrom markdownify import markdownify as md\n\n# Initialize FastMCP server\nmcp = FastMCP(\"markdown_converter\")\n\ndef is_binary_file(file_path):\n    \"\"\"Check if a file is binary by reading its first few bytes.\"\"\"\n    try:\n        with open(file_path, 'rb') as f:\n            chunk = f.read(1024)\n            if b'\\x00' in chunk:  # Null bytes indicate binary\n                return True\n        return False\n    except Exception:\n        return False\n\n@mcp.tool()\nasync def convert_to_markdown(source: str) -> str:\n    \"\"\"Converts content from various sources (HTTP/S webpages, local file paths, or Data URIs) into structured Markdown.\n\n    The tool automatically detects the source type and processes it accordingly. It preserves structural\n    elements like headings, lists, tables, and links.\n\n    Args:\n        source (str): The source of the content to be converted. This can be:\n                      - An HTTP or HTTPS URL (e.g., \"https://example.com\").\n                      - A local file path (e.g., \"./my_document.html\").\n                      - A Data URI (e.g., \"data:text/html;base64,PGgxPlRlc3Q8L2gxPg==\").\n\n    Returns:\n        A string containing the content converted to structured Markdown.\n\n    Raises:\n        ValueError: If the source is invalid, content cannot be fetched, or the source type is unsupported.\n        requests.exceptions.RequestException: If a network error occurs while fetching a URL.\n    \"\"\"\n    if not source or not source.strip():\n        raise ValueError(\"The 'source' parameter cannot be empty.\")\n\n    source = source.strip()\n    html_content = \"\"\n\n    try:\n        # 1. Detect and handle URL source\n        if re.match(r'^https?://', source):\n            # Security: Basic SSRF prevention by parsing the URL\n            parsed_url = urlparse(source)\n            if parsed_url.scheme not in ['http', 'https']:\n                raise ValueError(f\"Unsupported URL scheme: '{parsed_url.scheme}'. Only HTTP and HTTPS are supported protocols.\")\n            if not parsed_url.netloc:\n                raise ValueError(f\"Invalid URL: '{source}'\")\n            \n            # Set a user-agent to avoid being blocked by some websites\n            headers = {\n                'User-Agent': 'mcp-markdown-converter/1.0'\n            }\n            # Performance: Use a timeout to prevent long-running requests\n            response = requests.get(source, headers=headers, timeout=15)\n            # Robustness: Check for successful response\n            response.raise_for_status()\n            html_content = response.text\n\n        # 2. Detect and handle Data URI source\n        elif source.startswith('data:'):\n            match = re.match(r'data:(?P<mime_type>[^;]+);base64,(?P<data>.+)', source)\n            if not match:\n                raise ValueError(\"Invalid Data URI format. Expected format: 'data:<mime_type>;base64,<data>'\")\n            \n            mime_type = match.group('mime_type')\n            if 'text/html' not in mime_type and 'text/plain' not in mime_type:\n                raise ValueError(f\"Unsupported MIME type in Data URI: '{mime_type}'. Only 'text/html' and 'text/plain' are supported.\")\n\n            base64_data = match.group('data')\n            # Robustness: Handle potential base64 decoding errors\n            try:\n                decoded_bytes = base64.b64decode(base64_data)\n                html_content = decoded_bytes.decode('utf-8')\n            except (binascii.Error, UnicodeDecodeError) as e:\n                raise ValueError(f\"Failed to decode Data URI content: {e}\")\n\n        # 3. Handle local file path source\n        else:\n            # Security: Prevent path traversal attacks\n            abs_path = os.path.abspath(source)\n            cwd = os.getcwd()\n            if not abs_path.startswith(cwd):\n                raise ValueError(f\"Security error: File path '{source}' is outside the allowed directory.\")\n\n            # Check if input looks like Markdown content (for dependent operations)\n            if re.match(r'^(# |\\* |- |1\\. ).*$', source.strip(), re.MULTILINE):\n                html_content = source\n            elif os.path.isfile(abs_path):\n                # Robustness: Read file with specified encoding\n                try:\n                    # Check for binary files\n                    if is_binary_file(abs_path):\n                        raise ValueError(f\"Cannot process binary file: '{source}'. Only text files can be converted to Markdown.\")\n                    \n                    with open(abs_path, 'r', encoding='utf-8-sig') as f:\n                        html_content = f.read()\n                except Exception as e:\n                    raise IOError(f\"Error reading file '{source}': {e}\")\n            else:\n                # Treat as direct content if it doesn't match any source type\n                html_content = source\n        \n        if not html_content:\n            return \"The source content is empty.\"\n\n        # Functionality: Convert HTML to Markdown\n        return md(html_content, heading_style=\"ATX\")\n\n    except requests.exceptions.RequestException as e:\n        # Transparency: Provide clear network error messages\n        raise ValueError(f\"Network error fetching URL '{source}': {e}\")\n    except Exception as e:\n        # Transparency: Re-raise other exceptions with context\n        raise ValueError(f\"An error occurred while processing source '{source}': {e}\")\n\nif __name__ == \"__main__\":\n    # Ensure UTF-8 output for all transport protocols\n    if sys.stdout.encoding != 'utf-8':\n         sys.stdout.reconfigure(encoding='utf-8')\n    mcp.run()"
}