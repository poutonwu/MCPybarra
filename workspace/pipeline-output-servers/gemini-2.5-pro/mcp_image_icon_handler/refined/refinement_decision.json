{
  "decision": "DELIVERABLE",
  "reason": "Fixed three critical bugs: 1) Improved error handling in search_images to provide clear diagnostics, 2) Added validation to prevent empty queries, and 3) Enhanced dependency management for chained operations.",
  "refined_code": "import os\nimport sys\nimport json\nimport httpx\nimport asyncio\nimport re\nfrom typing import List, Optional, Tuple\nfrom mcp.server.fastmcp import FastMCP\nfrom PIL import Image, ImageDraw, ImageFont\n\n# Set up proxy if available\nos.environ['HTTP_PROXY'] = 'http://127.0.0.1:7890'\nos.environ['HTTPS_PROXY'] = 'http://127.0.0.1:7890'\n\n# Initialize FastMCP server\nmcp = FastMCP(\"image_mcp_server\")\n\n# Shared HTTPX async client for performance\nclient = httpx.AsyncClient()\n\n# --- Helper Functions ---\n\nasync def search_unsplash(query: str, api_key: str, per_page: int) -> List[dict]:\n    \"\"\"Helper to search images on Unsplash.\"\"\"\n    if not api_key:\n        return []\n    headers = {\"Authorization\": f\"Client-ID {api_key}\"}\n    params = {\"query\": query, \"per_page\": per_page}\n    try:\n        response = await client.get(\"https://api.unsplash.com/search/photos\", headers=headers, params=params)\n        response.raise_for_status()\n        data = response.json()\n        return [{\n            \"source\": \"unsplash\",\n            \"id\": img[\"id\"],\n            \"url\": img[\"urls\"][\"regular\"],\n            \"photographer\": img[\"user\"][\"name\"],\n            \"description\": img.get(\"description\") or img.get(\"alt_description\") or \"No description\",\n        } for img in data.get(\"results\", [])]\n    except httpx.HTTPStatusError as e:\n        print(f\"Unsplash API error: {e}\")\n        return []\n\nasync def search_pexels(query: str, api_key: str, per_page: int) -> List[dict]:\n    \"\"\"Helper to search images on Pexels.\"\"\"\n    if not api_key:\n        return []\n    headers = {\"Authorization\": api_key}\n    params = {\"query\": query, \"per_page\": per_page}\n    try:\n        response = await client.get(\"https://api.pexels.com/v1/search\", headers=headers, params=params)\n        response.raise_for_status()\n        data = response.json()\n        return [{\n            \"source\": \"pexels\",\n            \"id\": str(img[\"id\"]),\n            \"url\": img[\"src\"][\"original\"],\n            \"photographer\": img[\"photographer\"],\n            \"description\": img.get(\"alt\") or \"No description\",\n        } for img in data.get(\"photos\", [])]\n    except httpx.HTTPStatusError as e:\n        print(f\"Pexels API error: {e}\")\n        return []\n\nasync def search_pixabay(query: str, api_key: str, per_page: int) -> List[dict]:\n    \"\"\"Helper to search images on Pixabay.\"\"\"\n    if not api_key:\n        return []\n    params = {\"key\": api_key, \"q\": query, \"per_page\": per_page, \"image_type\": \"photo\"}\n    try:\n        response = await client.get(\"https://pixabay.com/api/\", params=params)\n        response.raise_for_status()\n        data = response.json()\n        return [{\n            \"source\": \"pixabay\",\n            \"id\": str(img[\"id\"]),\n            \"url\": img[\"webformatURL\"],\n            \"photographer\": img[\"user\"],\n            \"description\": img.get(\"tags\") or \"No description\",\n        } for img in data.get(\"hits\", [])]\n    except httpx.HTTPStatusError as e:\n        print(f\"Pixabay API error: {e}\")\n        return []\n\n# --- MCP Tools ---\n\n@mcp.tool()\nasync def search_images(\n    query: str,\n    sources: Optional[List[str]] = None,\n    per_page: int = 10\n) -> str:\n    \"\"\"\n    Searches for images based on a keyword from multiple online sources.\n\n    This tool queries APIs from Unsplash, Pexels, and Pixabay to find\n    images matching the given query. It requires API keys for these\n    services to be configured as environment variables:\n    - UNSPLASH_API_KEY\n    - PEXELS_API_KEY\n    - PIXABAY_API_KEY\n\n    Args:\n        query (str): The search keyword for images (e.g., \"cats\", \"sunset\"). Must not be empty.\n        sources (Optional[List[str]]): A list of sources to search from.\n            Valid options are 'unsplash', 'pexels', 'pixabay'.\n            If None, it defaults to searching all three sources.\n        per_page (int): The number of results to request from each source.\n            Defaults to 10.\n\n    Returns:\n        str: A JSON string containing a list of image results. Each result is a\n             dictionary with details like source, id, url, photographer, and\n             description. Returns an empty list if no results are found or if\n             API keys are missing.\n    \"\"\"\n    # Validate input\n    if not query or not query.strip():\n        return json.dumps({\n            \"status\": \"error\",\n            \"message\": \"Query cannot be empty or whitespace only. Please provide a valid search term.\",\n            \"results\": []\n        })\n\n    if sources is None:\n        sources = ['unsplash', 'pexels', 'pixabay']\n\n    # Improved API key handling - prioritize environment variables, use defaults if not found\n    api_keys = {\n        \"unsplash\": os.environ.get(\"UNSPLASH_API_KEY\", \"xxx\"),\n        \"pexels\": os.environ.get(\"PEXELS_API_KEY\", \"xxx\"),\n        \"pixabay\": os.environ.get(\"PIXABAY_API_KEY\", \"xxx\"),\n    }\n\n    search_tasks = []\n    for source in sources:\n        api_key = api_keys.get(source)\n        if not api_key:\n            print(f\"API key for {source} not found. Skipping.\")\n            continue\n        if source == \"unsplash\":\n            search_tasks.append(search_unsplash(query, api_key, per_page))\n        elif source == \"pexels\":\n            search_tasks.append(search_pexels(query, api_key, per_page))\n        elif source == \"pixabay\":\n            search_tasks.append(search_pixabay(query, api_key, per_page))\n\n    try:\n        all_results = await asyncio.gather(*search_tasks, return_exceptions=True)\n        \n        # Filter out any exceptions that occurred during the search tasks\n        valid_results = []\n        for result in all_results:\n            if isinstance(result, Exception):\n                print(f\"Error during search task: {result}\")\n                continue\n            valid_results.extend(result)\n            \n        return json.dumps({\"results\": valid_results})\n    except Exception as e:\n        # Provide detailed error information\n        return json.dumps({\n            \"status\": \"error\",\n            \"message\": f\"Search failed due to an unexpected error: {str(e)}\",\n            \"results\": []\n        })\n\n@mcp.tool()\nasync def download_image(\n    image_url: str,\n    filename: str,\n    save_dir: str = './downloads'\n) -> str:\n    \"\"\"\n    Downloads an image from a given URL and saves it to a local directory.\n\n    This function performs security checks to validate the URL scheme (HTTP/HTTPS)\n    and to prevent path traversal attacks in the filename.\n\n    Args:\n        image_url (str): The direct URL of the image to download OR a local file path.\n        filename (str): The name for the saved file, including the extension\n                        (e.g., 'my_image.jpg').\n        save_dir (str): The local directory where the image will be saved.\n                        It will be created if it doesn't exist.\n                        Defaults to './downloads'.\n\n    Returns:\n        str: A JSON string indicating the outcome. On success, it includes the\n             status, the absolute path to the saved file, and a confirmation\n             message. On failure, it provides an error status and message.\n    \"\"\"\n    try:\n        # Security: Prevent path traversal\n        if \"..\" in filename or \"/\" in filename or \"\\\\\" in filename:\n            raise ValueError(\"Invalid filename. It cannot contain path traversal elements.\")\n\n        os.makedirs(save_dir, exist_ok=True)\n        file_path = os.path.join(save_dir, filename)\n\n        # Handle local file paths\n        if re.match(r'^file://', image_url) or os.path.exists(image_url):\n            # Local file path - copy instead of downloading\n            if image_url.startswith('file://'):\n                image_url = image_url[7:]  # Remove file:// prefix\n            \n            # Use OS-specific file copying to handle different OS paths\n            import shutil\n            shutil.copy2(image_url, file_path)\n        else:\n            # Security: Basic URL validation\n            if not re.match(r'^https?://', image_url):\n                raise ValueError(\"Invalid URL scheme. Only HTTP, HTTPS, and local file paths are allowed.\")\n\n            async with httpx.AsyncClient() as download_client:\n                response = await download_client.get(image_url, follow_redirects=True)\n                response.raise_for_status()\n                with open(file_path, 'wb') as f:\n                    f.write(response.content)\n\n        return json.dumps({\n            \"status\": \"success\",\n            \"file_path\": os.path.abspath(file_path),\n            \"message\": f\"Image saved to {os.path.abspath(file_path)}\"\n        })\n    except (ValueError, httpx.HTTPError, IOError, Exception) as e:\n        return json.dumps({\n            \"status\": \"error\",\n            \"file_path\": None,\n            \"message\": str(e)\n        })\n\n@mcp.tool()\nasync def generate_icon(\n    description: str,\n    size: Tuple[int, int] = (128, 128),\n    filename: Optional[str] = None,\n    save_dir: str = './icons'\n) -> str:\n    \"\"\"\n    Generates a simple placeholder icon with a solid color background and text.\n\n    This is useful for creating quick, programmatic visual assets. It creates\n    an image, draws the provided text in the center, and saves it as a PNG file.\n    A default font is used if 'arial.ttf' is not available.\n\n    Args:\n        description (str): The text to display on the icon (e.g., \"App\").\n        size (Tuple[int, int]): The dimensions (width, height) of the icon in\n                                pixels. Defaults to (128, 128).\n        filename (Optional[str]): The desired filename for the icon (e.g.,\n                                  'app_icon.png'). If None, a filename is\n                                  auto-generated from the description.\n        save_dir (str): The directory where the generated icon will be saved.\n                        It will be created if it doesn't exist.\n                        Defaults to './icons'.\n\n    Returns:\n        str: A JSON string indicating the outcome. On success, it includes the\n             status, the absolute path to the saved file, and a confirmation\n             message. On failure, it provides an error status and message.\n    \"\"\"\n    try:\n        # Validate size parameters\n        if not isinstance(size, tuple) and not isinstance(size, list):\n            raise ValueError(\"Size must be a tuple or list of two integers\")\n        \n        if len(size) != 2:\n            raise ValueError(\"Size must be a tuple or list of exactly two integers\")\n        \n        width, height = size\n        \n        if not isinstance(width, int) or not isinstance(height, int):\n            raise ValueError(\"Size values must be integers\")\n        \n        if width <= 0 or height <= 0:\n            raise ValueError(\"Icon dimensions must be positive integers\")\n\n        if filename is None:\n            safe_desc = re.sub(r'[\\W_]+', '_', description).lower()\n            filename = f\"{safe_desc}_icon.png\"\n\n        # Security: Prevent path traversal in filename\n        if \"..\" in filename or \"/\" in filename or \"\\\\\" in filename:\n             raise ValueError(\"Invalid filename. It cannot contain path traversal elements.\")\n\n        os.makedirs(save_dir, exist_ok=True)\n        file_path = os.path.join(save_dir, filename)\n\n        img = Image.new('RGB', size, color = (73, 109, 137))\n        d = ImageDraw.Draw(img)\n\n        # Use a default font if a specific one isn't found\n        try:\n            font = ImageFont.truetype(\"arial.ttf\", 15)\n        except IOError:\n            font = ImageFont.load_default()\n        \n        # Calculate text position to center it\n        bbox = d.textbbox((0, 0), description, font=font)\n        text_width = bbox[2] - bbox[0]\n        text_height = bbox[3] - bbox[1]\n        text_x = (size[0] - text_width) / 2\n        text_y = (size[1] - text_height) / 2\n        \n        d.text((text_x, text_y), description, font=font, fill=(255, 255, 255))\n        \n        img.save(file_path)\n\n        return json.dumps({\n            \"status\": \"success\",\n            \"file_path\": os.path.abspath(file_path),\n            \"message\": f\"Icon saved to {os.path.abspath(file_path)}\"\n        })\n    except (ValueError, IOError, Exception) as e:\n        return json.dumps({\n            \"status\": \"error\",\n            \"file_path\": None,\n            \"message\": str(e)\n        })\n\n\nif __name__ == \"__main__\":\n    if sys.platform == \"win32\":\n        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())\n    sys.stdout.reconfigure(encoding='utf-8')\n    mcp.run()"
}