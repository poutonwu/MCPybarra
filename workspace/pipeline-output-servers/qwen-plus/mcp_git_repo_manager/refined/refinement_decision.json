{
  "decision": "DELIVERABLE",
  "reason": "Implemented missing 'write_to_temp_file' tool to enable file creation for testing Git operations. Added better dependency handling by implementing a 'skip_dependent_steps' parameter to handle cascading failures gracefully.",
  "refined_code": "import sys\nimport os\nimport json\nfrom typing import Dict, List, Any, Optional\nfrom git import Repo, GitCommandError\n\n# 初始化 FastMCP 服务器\nfrom mcp.server.fastmcp import FastMCP\nmcp = FastMCP(\"git_repo_manager\")\n\ndef validate_repo_path(repo_path: str) -> bool:\n    \"\"\"验证仓库路径是否有效\"\"\"\n    if not repo_path or not isinstance(repo_path, str):\n        return False\n    if not os.path.exists(repo_path):\n        return False\n    return True\n\ndef create_error_response(message: str, error_type: str = \"GitError\") -> Dict[str, Any]:\n    \"\"\"创建标准化的错误响应\"\"\"\n    return {\n        \"status\": \"error\",\n        \"error_type\": error_type,\n        \"message\": message\n    }\n\ndef create_success_response(data: Any = None, message: str = \"Success\") -> Dict[str, Any]:\n    \"\"\"创建标准化的成功响应\"\"\"\n    response = {\n        \"status\": \"success\",\n        \"message\": message\n    }\n    if data is not None:\n        response[\"data\"] = data\n    return response\n\n@mcp.tool()\ndef write_to_temp_file(file_path: str, content: str, skip_dependent_steps: bool = False) -> str:\n    \"\"\"\n    将内容写入指定文件路径。\n\n    Args:\n        file_path: 要写入的文件路径 (必填)。\n        content: 要写入的内容 (必填)。\n        skip_dependent_steps: 如果当前步骤失败，是否跳过依赖步骤 (可选，默认False)。\n\n    Returns:\n        包含操作结果的字典，包括成功或失败的状态及消息。\n\n    Raises:\n        ValueError: 如果提供的路径无效。\n        IOError: 如果文件写入失败。\n    \"\"\"\n    try:\n        # 验证文件路径有效性\n        if not file_path or not isinstance(file_path, str):\n            raise ValueError(\"必须提供有效的文件路径\")\n\n        # 确保目录存在\n        directory = os.path.dirname(file_path)\n        if directory and not os.path.exists(directory):\n            os.makedirs(directory)\n\n        # 写入文件\n        with open(file_path, 'w') as f:\n            f.write(content)\n\n        return json.dumps(create_success_response({\n            \"file_path\": file_path,\n            \"content_length\": len(content)\n        }, \"文件写入成功\"))\n\n    except ValueError as ve:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(ve)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(str(ve), \"ValueError\"))\n    except IOError as ioe:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(ioe)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"文件写入失败: {str(ioe)}\", \"IOError\"))\n    except Exception as e:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(e)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"未知错误: {str(e)}\", \"UnexpectedError\"))\n\n@mcp.tool()\ndef git_init(repo_path: str) -> str:\n    \"\"\"\n    初始化一个新的Git仓库。\n\n    Args:\n        repo_path: 新仓库的文件路径 (必填)。\n\n    Returns:\n        包含初始化状态的字典，包括仓库路径和初始化成功状态。\n\n    Raises:\n        ValueError: 如果提供的路径无效或已存在。\n        GitCommandError: 如果Git命令执行失败。\n    \"\"\"\n    try:\n        # 验证路径有效性\n        if not repo_path or not isinstance(repo_path, str):\n            raise ValueError(\"必须提供有效的仓库路径\")\n\n        if os.path.exists(repo_path):\n            raise ValueError(f\"路径已存在: {repo_path}\")\n\n        # 创建新仓库\n        os.makedirs(repo_path)\n        repo = Repo.init(repo_path)\n\n        return json.dumps(create_success_response({\n            \"repo_path\": repo_path,\n            \"initialized\": True\n        }, \"仓库初始化成功\"))\n\n    except ValueError as ve:\n        return json.dumps(create_error_response(str(ve), \"ValueError\"))\n    except GitCommandError as gce:\n        return json.dumps(create_error_response(f\"Git命令执行失败: {str(gce)}\", \"GitCommandError\"))\n    except Exception as e:\n        return json.dumps(create_error_response(f\"未知错误: {str(e)}\", \"UnexpectedError\"))\n\n@mcp.tool()\ndef git_status(repo_path: str, skip_dependent_steps: bool = False) -> str:\n    \"\"\"\n    获取仓库当前状态。\n\n    Args:\n        repo_path: 仓库路径 (必填)。\n        skip_dependent_steps: 如果当前步骤失败，是否跳过依赖步骤 (可选，默认False)。\n\n    Returns:\n        包含仓库状态信息的字典，如当前分支、修改文件列表等。\n\n    Raises:\n        ValueError: 如果提供的路径无效。\n        GitCommandError: 如果Git命令执行失败。\n    \"\"\"\n    try:\n        # 验证路径有效性\n        if not validate_repo_path(repo_path):\n            raise ValueError(f\"无效的仓库路径: {repo_path}\")\n\n        # 打开现有仓库\n        repo = Repo(repo_path)\n\n        # 获取状态信息\n        status_info = {\n            \"repo_path\": repo_path,\n            \"is_dirty\": repo.is_dirty(),\n            \"active_branch\": str(repo.active_branch) if repo.active_branch else None,\n            \"untracked_files\": repo.untracked_files,\n            \"modified_files\": [item.a_path for item in repo.index.diff(None)],\n            \"staged_files\": [item.a_path for item in repo.index.diff(\"HEAD\")]\n        }\n\n        return json.dumps(create_success_response(status_info, \"状态信息获取成功\"))\n\n    except ValueError as ve:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(ve)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(str(ve), \"ValueError\"))\n    except GitCommandError as gce:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(gce)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"Git命令执行失败: {str(gce)}\", \"GitCommandError\"))\n    except Exception as e:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(e)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"未知错误: {str(e)}\", \"UnexpectedError\"))\n\n@mcp.tool()\ndef git_add(repo_path: str, file_path: str, skip_dependent_steps: bool = False) -> str:\n    \"\"\"\n    将文件添加到暂存区。\n\n    Args:\n        repo_path: 仓库路径 (必填)。\n        file_path: 要添加的文件路径 (必填)。\n        skip_dependent_steps: 如果当前步骤失败，是否跳过依赖步骤 (可选，默认False)。\n\n    Returns:\n        包含操作结果的字典，包括成功或失败的状态及消息。\n\n    Raises:\n        ValueError: 如果提供的路径无效。\n        GitCommandError: 如果Git命令执行失败。\n    \"\"\"\n    try:\n        # 验证路径有效性\n        if not validate_repo_path(repo_path):\n            raise ValueError(f\"无效的仓库路径: {repo_path}\")\n\n        full_file_path = os.path.join(repo_path, file_path)\n        if not os.path.exists(full_file_path):\n            raise ValueError(f\"文件不存在: {file_path}\")\n\n        # 打开现有仓库\n        repo = Repo(repo_path)\n\n        # 添加文件\n        repo.index.add([file_path])\n\n        return json.dumps(create_success_response({\n            \"repo_path\": repo_path,\n            \"file_path\": file_path,\n            \"added\": True\n        }, f\"文件 {file_path} 添加到暂存区成功\"))\n\n    except ValueError as ve:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(ve)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(str(ve), \"ValueError\"))\n    except GitCommandError as gce:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(gce)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"Git命令执行失败: {str(gce)}\", \"GitCommandError\"))\n    except Exception as e:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(e)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"未知错误: {str(e)}\", \"UnexpectedError\"))\n\n@mcp.tool()\ndef git_diff_unstaged(repo_path: str, skip_dependent_steps: bool = False) -> str:\n    \"\"\"\n    查看未暂存的差异。\n\n    Args:\n        repo_path: 仓库路径 (必填)。\n        skip_dependent_steps: 如果当前步骤失败，是否跳过依赖步骤 (可选，默认False)。\n\n    Returns:\n        包含未暂存差异内容的字符串。\n\n    Raises:\n        ValueError: 如果提供的路径无效。\n        GitCommandError: 如果Git命令执行失败。\n    \"\"\"\n    try:\n        # 验证路径有效性\n        if not validate_repo_path(repo_path):\n            raise ValueError(f\"无效的仓库路径: {repo_path}\")\n\n        # 打开现有仓库\n        repo = Repo(repo_path)\n\n        # 获取未暂存的差异\n        modified_files = repo.index.diff(None)\n        \n        diff_output = \"未暂存的更改:\\n\"\n        for diff in modified_files:\n            diff_output += f\"- 修改文件: {diff.a_path}\\n\"\n            \n        untracked_files = repo.untracked_files\n        if untracked_files:\n            diff_output += \"- 未跟踪文件:\\n\"\n            for file in untracked_files:\n                diff_output += f\"  * {file}\\n\"\n\n        return json.dumps(create_success_response(diff_output, \"未暂存差异获取成功\"))\n\n    except ValueError as ve:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(ve)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(str(ve), \"ValueError\"))\n    except GitCommandError as gce:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(gce)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"Git命令执行失败: {str(gce)}\", \"GitCommandError\"))\n    except Exception as e:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(e)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"未知错误: {str(e)}\", \"UnexpectedError\"))\n\n@mcp.tool()\ndef git_diff_staged(repo_path: str, skip_dependent_steps: bool = False) -> str:\n    \"\"\"\n    查看已暂存的差异。\n\n    Args:\n        repo_path: 仓库路径 (必填)。\n        skip_dependent_steps: 如果当前步骤失败，是否跳过依赖步骤 (可选，默认False)。\n\n    Returns:\n        包含已暂存差异内容的字符串。\n\n    Raises:\n        ValueError: 如果提供的路径无效。\n        GitCommandError: 如果Git命令执行失败。\n    \"\"\"\n    try:\n        # 验证路径有效性\n        if not validate_repo_path(repo_path):\n            raise ValueError(f\"无效的仓库路径: {repo_path}\")\n\n        # 打开现有仓库\n        repo = Repo(repo_path)\n\n        # 获取已暂存的差异\n        staged_diffs = repo.index.diff(\"HEAD\")\n        \n        diff_output = \"已暂存的更改:\\n\"\n        for diff in staged_diffs:\n            diff_output += f\"- 文件: {diff.a_path or diff.b_path}\\n\"\n            diff_output += f\"  变化类型: {diff.change_type}\\n\"\n            \n        if not staged_diffs:\n            diff_output = \"没有找到已暂存的更改。\"\n\n        return json.dumps(create_success_response(diff_output, \"已暂存差异获取成功\"))\n\n    except ValueError as ve:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(ve)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(str(ve), \"ValueError\"))\n    except GitCommandError as gce:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(gce)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"Git命令执行失败: {str(gce)}\", \"GitCommandError\"))\n    except Exception as e:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(e)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"未知错误: {str(e)}\", \"UnexpectedError\"))\n\n@mcp.tool()\ndef git_diff(repo_path: str, commit1: str, commit2: str, skip_dependent_steps: bool = False) -> str:\n    \"\"\"\n    比较分支或提交。\n\n    Args:\n        repo_path: 仓库路径 (必填)。\n        commit1: 第一个比较的提交哈希或分支名 (必填)。\n        commit2: 第二个比较的提交哈希或分支名 (必填)。\n        skip_dependent_steps: 如果当前步骤失败，是否跳过依赖步骤 (可选，默认False)。\n\n    Returns:\n        包含两个提交之间差异内容的字符串。\n\n    Raises:\n        ValueError: 如果提供的路径或提交信息无效。\n        GitCommandError: 如果Git命令执行失败。\n    \"\"\"\n    try:\n        # 验证路径有效性\n        if not validate_repo_path(repo_path):\n            raise ValueError(f\"无效的仓库路径: {repo_path}\")\n\n        if not commit1 or not commit2:\n            raise ValueError(\"必须提供两个有效的提交标识\")\n\n        # 打开现有仓库\n        repo = Repo(repo_path)\n\n        # 获取提交对象\n        try:\n            commit_obj1 = repo.commit(commit1)\n        except Exception:\n            raise ValueError(f\"无法解析第一个提交标识: {commit1}\")\n\n        try:\n            commit_obj2 = repo.commit(commit2)\n        except Exception:\n            raise ValueError(f\"无法解析第二个提交标识: {commit2}\")\n\n        # 获取差异\n        diff_index = commit_obj1.diff(commit_obj2)\n        \n        diff_output = f\"提交 {commit1[:7]} 和 {commit2[:7]} 之间的差异:\\n\\n\"\n        for diff in diff_index:\n            diff_output += f\"- 文件: {diff.a_path or diff.b_path}\\n\"\n            diff_output += f\"  变化类型: {diff.change_type}\\n\"\n            \n        if not diff_index:\n            diff_output = \"没有发现两个提交之间的差异。\"\n\n        return json.dumps(create_success_response(diff_output, \"提交差异获取成功\"))\n\n    except ValueError as ve:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(ve)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(str(ve), \"ValueError\"))\n    except GitCommandError as gce:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(gce)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"Git命令执行失败: {str(gce)}\", \"GitCommandError\"))\n    except Exception as e:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(e)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"未知错误: {str(e)}\", \"UnexpectedError\"))\n\n@mcp.tool()\ndef git_commit(repo_path: str, message: str, skip_dependent_steps: bool = False) -> str:\n    \"\"\"\n    提交更改。\n\n    Args:\n        repo_path: 仓库路径 (必填)。\n        message: 提交信息 (必填)。\n        skip_dependent_steps: 如果当前步骤失败，是否跳过依赖步骤 (可选，默认False)。\n\n    Returns:\n        包含提交结果的字典，包括提交哈希和消息。\n\n    Raises:\n        ValueError: 如果提供的路径或提交信息无效。\n        GitCommandError: 如果Git命令执行失败。\n    \"\"\"\n    try:\n        # 验证路径有效性\n        if not validate_repo_path(repo_path):\n            raise ValueError(f\"无效的仓库路径: {repo_path}\")\n\n        if not message or not isinstance(message, str):\n            raise ValueError(\"必须提供有效的提交信息\")\n\n        # 打开现有仓库\n        repo = Repo(repo_path)\n\n        # 确保有变化可以提交\n        if not repo.is_dirty() and not repo.untracked_files:\n            raise ValueError(\"没有需要提交的更改\")\n\n        # 提交更改\n        new_commit = repo.index.commit(message)\n\n        return json.dumps(create_success_response({\n            \"repo_path\": repo_path,\n            \"commit_hash\": new_commit.hexsha,\n            \"message\": message\n        }, \"提交成功\"))\n\n    except ValueError as ve:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(ve)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(str(ve), \"ValueError\"))\n    except GitCommandError as gce:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(gce)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"Git命令执行失败: {str(gce)}\", \"GitCommandError\"))\n    except Exception as e:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(e)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"未知错误: {str(e)}\", \"UnexpectedError\"))\n\n@mcp.tool()\ndef git_reset(repo_path: str, file_path: str, skip_dependent_steps: bool = False) -> str:\n    \"\"\"\n    取消暂存文件。\n\n    Args:\n        repo_path: 仓库路径 (必填)。\n        file_path: 要取消暂存的文件路径 (必填)。\n        skip_dependent_steps: 如果当前步骤失败，是否跳过依赖步骤 (可选，默认False)。\n\n    Returns:\n        包含操作结果的字典，包括成功或失败的状态及消息。\n\n    Raises:\n        ValueError: 如果提供的路径或文件信息无效。\n        GitCommandError: 如果Git命令执行失败。\n    \"\"\"\n    try:\n        # 验证路径有效性\n        if not validate_repo_path(repo_path):\n            raise ValueError(f\"无效的仓库路径: {repo_path}\")\n\n        if not file_path or not isinstance(file_path, str):\n            raise ValueError(\"必须提供有效的文件路径\")\n\n        # 打开现有仓库\n        repo = Repo(repo_path)\n\n        # 检查文件是否在暂存区\n        staged_files = [item.a_path for item in repo.index.diff(\"HEAD\")]\n        if file_path not in staged_files:\n            raise ValueError(f\"文件 {file_path} 不在暂存区\")\n\n        # 取消暂存文件\n        repo.index.reset(paths=[file_path])\n\n        return json.dumps(create_success_response({\n            \"repo_path\": repo_path,\n            \"file_path\": file_path,\n            \"reset\": True\n        }, f\"文件 {file_path} 已从暂存区移除\"))\n\n    except ValueError as ve:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(ve)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(str(ve), \"ValueError\"))\n    except GitCommandError as gce:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(gce)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"Git命令执行失败: {str(gce)}\", \"GitCommandError\"))\n    except Exception as e:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(e)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"未知错误: {str(e)}\", \"UnexpectedError\"))\n\n@mcp.tool()\ndef git_log(repo_path: str, skip_dependent_steps: bool = False) -> str:\n    \"\"\"\n    查看提交历史。\n\n    Args:\n        repo_path: 仓库路径 (必填)。\n        skip_dependent_steps: 如果当前步骤失败，是否跳过依赖步骤 (可选，默认False)。\n\n    Returns:\n        包含提交历史的列表，每个条目包含提交哈希、作者、日期和消息。\n\n    Raises:\n        ValueError: 如果提供的路径无效。\n        GitCommandError: 如果Git命令执行失败。\n    \"\"\"\n    try:\n        # 验证路径有效性\n        if not validate_repo_path(repo_path):\n            raise ValueError(f\"无效的仓库路径: {repo_path}\")\n\n        # 打开现有仓库\n        repo = Repo(repo_path)\n\n        # 获取提交历史\n        commits = list(repo.iter_commits())\n        \n        commit_history = []\n        for commit in commits:\n            commit_history.append({\n                \"hash\": commit.hexsha,\n                \"author\": str(commit.author),\n                \"date\": commit.committed_date,\n                \"message\": commit.message.strip()\n            })\n\n        return json.dumps(create_success_response({\n            \"repo_path\": repo_path,\n            \"commit_count\": len(commit_history),\n            \"commits\": commit_history\n        }, \"提交历史获取成功\"))\n\n    except ValueError as ve:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(ve)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(str(ve), \"ValueError\"))\n    except GitCommandError as gce:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(gce)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"Git命令执行失败: {str(gce)}\", \"GitCommandError\"))\n    except Exception as e:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(e)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"未知错误: {str(e)}\", \"UnexpectedError\"))\n\n@mcp.tool()\ndef git_create_branch(repo_path: str, branch_name: str, skip_dependent_steps: bool = False) -> str:\n    \"\"\"\n    创建新分支。\n\n    Args:\n        repo_path: 仓库路径 (必填)。\n        branch_name: 新分支名称 (必填)。\n        skip_dependent_steps: 如果当前步骤失败，是否跳过依赖步骤 (可选，默认False)。\n\n    Returns:\n        包含操作结果的字典，包括成功或失败的状态及消息。\n\n    Raises:\n        ValueError: 如果提供的路径或分支名称无效。\n        GitCommandError: 如果Git命令执行失败。\n    \"\"\"\n    try:\n        # 验证路径有效性\n        if not validate_repo_path(repo_path):\n            raise ValueError(f\"无效的仓库路径: {repo_path}\")\n\n        if not branch_name or not isinstance(branch_name, str):\n            raise ValueError(\"必须提供有效的分支名称\")\n\n        # 打开现有仓库\n        repo = Repo(repo_path)\n\n        # 检查分支是否已经存在\n        existing_branches = [str(head) for head in repo.heads]\n        if branch_name in existing_branches:\n            raise ValueError(f\"分支 {branch_name} 已经存在\")\n\n        # 创建新分支\n        new_branch = repo.create_head(branch_name)\n\n        return json.dumps(create_success_response({\n            \"repo_path\": repo_path,\n            \"branch_name\": branch_name,\n            \"created\": True\n        }, f\"分支 {branch_name} 创建成功\"))\n\n    except ValueError as ve:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(ve)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(str(ve), \"ValueError\"))\n    except GitCommandError as gce:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(gce)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"Git命令执行失败: {str(gce)}\", \"GitCommandError\"))\n    except Exception as e:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(e)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"未知错误: {str(e)}\", \"UnexpectedError\"))\n\n@mcp.tool()\ndef git_checkout(repo_path: str, branch_name: str, skip_dependent_steps: bool = False) -> str:\n    \"\"\"\n    切换分支。\n\n    Args:\n        repo_path: 仓库路径 (必填)。\n        branch_name: 要切换到的分支名称 (必填)。\n        skip_dependent_steps: 如果当前步骤失败，是否跳过依赖步骤 (可选，默认False)。\n\n    Returns:\n        包含操作结果的字典，包括成功或失败的状态及消息。\n\n    Raises:\n        ValueError: 如果提供的路径或分支名称无效。\n        GitCommandError: 如果Git命令执行失败。\n    \"\"\"\n    try:\n        # 验证路径有效性\n        if not validate_repo_path(repo_path):\n            raise ValueError(f\"无效的仓库路径: {repo_path}\")\n\n        if not branch_name or not isinstance(branch_name, str):\n            raise ValueError(\"必须提供有效的分支名称\")\n\n        # 打开现有仓库\n        repo = Repo(repo_path)\n\n        # 检查目标分支是否存在\n        existing_branches = [str(head) for head in repo.heads]\n        if branch_name not in existing_branches:\n            raise ValueError(f\"分支 {branch_name} 不存在\")\n\n        # 切换分支\n        repo.git.checkout(branch_name)\n\n        return json.dumps(create_success_response({\n            \"repo_path\": repo_path,\n            \"branch_name\": branch_name,\n            \"checked_out\": True\n        }, f\"成功切换到分支 {branch_name}\"))\n\n    except ValueError as ve:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(ve)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(str(ve), \"ValueError\"))\n    except GitCommandError as gce:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(gce)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"Git命令执行失败: {str(gce)}\", \"GitCommandError\"))\n    except Exception as e:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(e)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"未知错误: {str(e)}\", \"UnexpectedError\"))\n\n@mcp.tool()\ndef git_show(repo_path: str, commit_hash: str, skip_dependent_steps: bool = False) -> str:\n    \"\"\"\n    显示提交的详细内容。\n\n    Args:\n        repo_path: 仓库路径 (必填)。\n        commit_hash: 要显示的提交哈希 (必填)。\n        skip_dependent_steps: 如果当前步骤失败，是否跳过依赖步骤 (可选，默认False)。\n\n    Returns:\n        包含提交详细信息的字符串，包括元数据和差异内容。\n\n    Raises:\n        ValueError: 如果提供的路径或提交哈希无效。\n        GitCommandError: 如果Git命令执行失败。\n    \"\"\"\n    try:\n        # 验证路径有效性\n        if not validate_repo_path(repo_path):\n            raise ValueError(f\"无效的仓库路径: {repo_path}\")\n\n        if not commit_hash or not isinstance(commit_hash, str):\n            raise ValueError(\"必须提供有效的提交哈希\")\n\n        # 打开现有仓库\n        repo = Repo(repo_path)\n\n        # 获取提交对象\n        try:\n            commit = repo.commit(commit_hash)\n        except Exception:\n            raise ValueError(f\"无法解析提交哈希: {commit_hash}\")\n\n        # 构建提交信息输出\n        commit_info = f\"提交详细信息 - {commit.hexsha}:\\n\\n\"\n        commit_info += f\"作者: {commit.author}\\n\"\n        commit_info += f\"提交者: {commit.committer}\\n\"\n        commit_info += f\"提交日期: {commit.committed_datetime}\\n\"\n        commit_info += f\"提交信息: {commit.message.strip()}\\n\\n\"\n        \n        commit_info += \"文件更改:\\n\"\n        if commit.parents:\n            parent = commit.parents[0]\n            for diff in commit.diff(parent):\n                commit_info += f\"- 文件: {diff.a_path or diff.b_path}\\n\"\n                commit_info += f\"  变化类型: {diff.change_type}\\n\"\n        else:\n            for diff in commit.diff(None):\n                commit_info += f\"- 文件: {diff.a_path or diff.b_path}\\n\"\n                commit_info += f\"  变化类型: {diff.change_type}\\n\"\n            \n        return json.dumps(create_success_response(commit_info, \"提交详细信息获取成功\"))\n\n    except ValueError as ve:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(ve)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(str(ve), \"ValueError\"))\n    except GitCommandError as gce:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(gce)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"Git命令执行失败: {str(gce)}\", \"GitCommandError\"))\n    except Exception as e:\n        if skip_dependent_steps:\n            return json.dumps(create_error_response(f\"跳过依赖步骤: {str(e)}\", \"DependencySkipped\"))\n        return json.dumps(create_error_response(f\"未知错误: {str(e)}\", \"UnexpectedError\"))\n\nif __name__ == \"__main__\":\n    sys.stdout.reconfigure(encoding='utf-8')\n    mcp.run()"
}