{
  "decision": "DELIVERABLE",
  "reason": "Fixed two critical bugs: 1) Set a default key_path in the connect tool to enable successful connection without manual configuration, and 2) Improved error handling across all tools to detect and report unresolved session IDs more clearly with actionable error messages.",
  "refined_code": "import sys\nimport paramiko\nimport uuid\nimport logging\nimport json\nimport os\nimport time\nfrom typing import Optional, Dict, List, Any\nfrom dataclasses import dataclass, asdict\nfrom mcp.server.fastmcp import FastMCP\n\n# 初始化 FastMCP 服务器\nmcp = FastMCP(\"ssh_mcp_server\")\n\n# 配置日志记录\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__')\n\n@dataclass\nclass SessionInfo:\n    session_id: str\n    host: str\n    username: str\n    connected_at: float\n\n# 存储活跃会话的字典\nactive_sessions: Dict[str, Dict[str, Any]] = {}\n\n@mcp.tool()\ndef connect(host: str = \"10.70.4.146\", port: int = 26002, username: str = \"pengbocheng\", \n           password: Optional[str] = None, key_path: Optional[str] = \"~/.ssh/id_rsa\", \n           key_passphrase: Optional[str] = None) -> str:\n    \"\"\"\n    建立与远程SSH服务器的安全连接，支持密码或密钥认证。\n\n    Args:\n        host: 目标SSH服务器的IP地址或主机名。（默认：10.70.4.146）\n        port: SSH服务端口号，默认22。（默认：26002）\n        username: 登录用户名。（默认：pengbocheng）\n        password: 登录密码（如果使用密钥认证则不需要）。\n        key_path: 私钥文件路径（如果使用密码认证则不需要）。默认使用 ~/.ssh/id_rsa\n        key_passphrase: 密钥文件的密码短语。\n\n    Returns:\n        包含会话ID的字符串，用于后续操作标识该连接。\n\n    Raises:\n        ValueError: 如果参数验证失败。\n        paramiko.SSHException: 如果SSH连接失败。\n    \"\"\"\n    try:\n        # 参数验证\n        if not host or not isinstance(host, str):\n            raise ValueError(\"'host' 必须是有效的字符串。\")\n        if not isinstance(port, int) or port <= 0 or port > 65535:\n            raise ValueError(\"'port' 必须是1到65535之间的有效整数。\")\n        if not username or not isinstance(username, str):\n            raise ValueError(\"'username' 必须是有效的字符串。\")\n        \n        # 创建SSH客户端\n        ssh = paramiko.SSHClient()\n        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n        \n        # 使用密码或密钥进行连接\n        if password is not None:\n            ssh.connect(hostname=host, port=port, username=username, password=password)\n        elif key_path is not None:\n            # Expand user home directory if needed\n            key_path_expanded = os.path.expanduser(key_path)\n            \n            # Check if key file exists\n            if not os.path.exists(key_path_expanded):\n                raise ValueError(f\"密钥文件不存在: {key_path_expanded}\")\n                \n            key = paramiko.RSAKey(filename=key_path_expanded, password=key_passphrase)\n            ssh.connect(hostname=host, port=port, username=username, pkey=key)\n        else:\n            raise ValueError(\"必须提供密码或密钥路径进行认证。\")\n        \n        # 生成唯一会话ID\n        session_id = str(uuid.uuid4())\n        \n        # 存储会话信息和SSH连接对象\n        active_sessions[session_id] = {\n            'client': ssh,\n            'host': host,\n            'username': username,\n            'connected_at': time.time()\n        }\n        \n        logger.info(f\"成功建立SSH连接到 {host}:{port} 作为 {username}\")\n        return session_id\n    except Exception as e:\n        logger.error(f\"SSH连接失败: {str(e)}\")\n        raise\n\n@mcp.tool()\ndef disconnect(session_id: str) -> str:\n    \"\"\"\n    安全断开指定的SSH连接并释放相关资源。\n\n    Args:\n        session_id: 要断开的会话唯一标识符。\n\n    Returns:\n        包含操作结果状态的字符串（成功/失败）。\n\n    Raises:\n        ValueError: 如果会话ID无效或格式不正确。\n    \"\"\"\n    try:\n        # 参数验证\n        if not session_id or not isinstance(session_id, str):\n            raise ValueError(f\"无效的会话ID: {session_id}. 必须是非空字符串。\")\n            \n        if session_id not in active_sessions:\n            raise ValueError(f\"会话ID不存在: {session_id}. 当前活跃会话: {list(active_sessions.keys())}\")\n        \n        # 获取SSH客户端并关闭连接\n        ssh_client = active_sessions[session_id]['client']\n        ssh_client.close()\n        \n        # 从活跃会话中移除\n        del active_sessions[session_id]\n        \n        logger.info(f\"成功断开会话ID: {session_id}\")\n        return f\"会话 {session_id} 已成功断开。\"\n    except Exception as e:\n        logger.error(f\"断开会话失败: {str(e)}\")\n        raise\n\n@mcp.tool()\ndef list_sessions() -> str:\n    \"\"\"\n    列出所有当前活跃的SSH会话信息。\n\n    Args:\n        无\n\n    Returns:\n        JSON格式字符串，包含活跃会话列表及详细信息。\n    \"\"\"\n    try:\n        # 构建活跃会话列表\n        sessions = []\n        for session_id, session_info in active_sessions.items():\n            sessions.append({\n                'session_id': session_id,\n                'host': session_info['host'],\n                'username': session_info['username'],\n                'connected_at': session_info['connected_at']\n            })\n        \n        result = {\n            'active_sessions': sessions,\n            'total_sessions': len(sessions)\n        }\n        \n        logger.info(f\"列出 {len(sessions)} 个活跃会话\")\n        return json.dumps(result)\n    except Exception as e:\n        logger.error(f\"获取会话列表失败: {str(e)}\")\n        raise\n\n@mcp.tool()\ndef execute(session_id: str, command: str, timeout: int = 60, stdin_input: Optional[str] = None) -> str:\n    \"\"\"\n    在指定的SSH会话中执行远程命令，支持标准输入和超时设置。\n\n    Args:\n        session_id: 要执行命令的会话ID。\n        command: 要执行的远程命令。\n        timeout: 命令执行超时时间(秒)，默认60秒。\n        stdin_input: 传递给命令的标准输入内容。\n\n    Returns:\n        JSON格式字符串，包含命令的标准输出、错误输出、退出状态码和执行时间。\n\n    Raises:\n        ValueError: 如果参数验证失败。\n        RuntimeError: 如果命令执行失败。\n    \"\"\"\n    try:\n        # 参数验证\n        if not session_id or not isinstance(session_id, str):\n            raise ValueError(f\"无效的会话ID: {session_id}. 必须是非空字符串。\")\n            \n        if session_id not in active_sessions:\n            raise ValueError(f\"会话ID不存在: {session_id}. 当前活跃会话: {list(active_sessions.keys())}\")\n            \n        if not command or not isinstance(command, str):\n            raise ValueError(\"'command' 必须是非空字符串。\")\n            \n        if not isinstance(timeout, int) or timeout <= 0:\n            raise ValueError(\"'timeout' 必须是大于0的有效整数。\")\n        \n        # 获取SSH客户端\n        ssh_client = active_sessions[session_id]['client']\n        \n        # 执行命令\n        start_time = time.time()\n        stdin, stdout, stderr = ssh_client.exec_command(command, timeout=timeout)\n        \n        # 处理标准输入\n        if stdin_input is not None:\n            stdin.write(stdin_input)\n            stdin.flush()\n        \n        # 获取输出和错误信息\n        stdout_data = stdout.read().decode('utf-8')\n        stderr_data = stderr.read().decode('utf-8')\n        exit_code = stdout.channel.recv_exit_status()\n        execution_time = time.time() - start_time\n        \n        result = {\n            'stdout': stdout_data,\n            'stderr': stderr_data,\n            'exit_code': exit_code,\n            'execution_time': execution_time\n        }\n        \n        logger.info(f\"在会话 {session_id} 执行命令完成，退出码: {exit_code}\")\n        return json.dumps(result)\n    except Exception as e:\n        logger.error(f\"执行命令失败: {str(e)}\")\n        raise\n\n@mcp.tool()\ndef upload(session_id: str, local_path: str, remote_path: str) -> str:\n    \"\"\"\n    将本地文件上传到远程SSH服务器的指定路径。\n\n    Args:\n        session_id: 使用的SSH会话ID。\n        local_path: 本地文件的完整路径。\n        remote_path: 远程服务器上的目标路径。\n\n    Returns:\n        包含传输结果状态的字符串（成功/失败）及传输统计信息。\n\n    Raises:\n        ValueError: 如果参数验证失败。\n    \"\"\"\n    try:\n        # 参数验证\n        if not session_id or not isinstance(session_id, str):\n            raise ValueError(f\"无效的会话ID: {session_id}. 必须是非空字符串。\")\n            \n        if session_id not in active_sessions:\n            raise ValueError(f\"会话ID不存在: {session_id}. 当前活跃会话: {list(active_sessions.keys())}\")\n            \n        if not local_path or not isinstance(local_path, str):\n            raise ValueError(\"'local_path' 必须是非空字符串。\")\n            \n        if not os.path.exists(local_path):\n            raise ValueError(f\"本地文件不存在: {local_path}\")\n            \n        if not remote_path or not isinstance(remote_path, str):\n            raise ValueError(\"'remote_path' 必须是非空字符串。\")\n        \n        # 获取SFTP客户端\n        sftp = active_sessions[session_id]['client'].open_sftp()\n        \n        # 上传文件\n        sftp.put(local_path, remote_path)\n        \n        # 获取文件大小\n        local_size = os.path.getsize(local_path)\n        \n        result = {\n            'status': 'success',\n            'message': f\"文件 {local_path} 成功上传到 {remote_path}\",\n            'transferred_bytes': local_size\n        }\n        \n        logger.info(f\"文件上传成功: {local_path} -> {remote_path}\")\n        return json.dumps(result)\n    except Exception as e:\n        logger.error(f\"文件上传失败: {str(e)}\")\n        raise\n\n@mcp.tool()\ndef download(session_id: str, remote_path: str, local_path: str) -> str:\n    \"\"\"\n    从远程SSH服务器下载文件到本地指定路径。\n\n    Args:\n        session_id: 使用的SSH会话ID。\n        remote_path: 远程服务器上的文件路径。\n        local_path: 本地保存文件的完整路径。\n\n    Returns:\n        包含传输结果状态的字符串（成功/失败）及传输统计信息。\n\n    Raises:\n        ValueError: 如果参数验证失败。\n    \"\"\"\n    try:\n        # 参数验证\n        if not session_id or not isinstance(session_id, str):\n            raise ValueError(f\"无效的会话ID: {session_id}. 必须是非空字符串。\")\n            \n        if session_id not in active_sessions:\n            raise ValueError(f\"会话ID不存在: {session_id}. 当前活跃会话: {list(active_sessions.keys())}\")\n            \n        if not remote_path or not isinstance(remote_path, str):\n            raise ValueError(\"'remote_path' 必须是非空字符串。\")\n            \n        if not local_path or not isinstance(local_path, str):\n            raise ValueError(\"'local_path' 必须是非空字符串。\")\n        \n        # 获取SFTP客户端\n        sftp = active_sessions[session_id]['client'].open_sftp()\n        \n        # 下载文件\n        sftp.get(remote_path, local_path)\n        \n        # 获取文件大小\n        remote_size = sftp.stat(remote_path).st_size\n        \n        result = {\n            'status': 'success',\n            'message': f\"文件 {remote_path} 成功下载到 {local_path}\",\n            'transferred_bytes': remote_size\n        }\n        \n        logger.info(f\"文件下载成功: {remote_path} -> {local_path}\")\n        return json.dumps(result)\n    except Exception as e:\n        logger.error(f\"文件下载失败: {str(e)}\")\n        raise\n\nif __name__ == \"__main__\":\n    sys.stdout.reconfigure(encoding='utf-8')\n    mcp.run()"
}