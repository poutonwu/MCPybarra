{
  "decision": "DELIVERABLE",
  "reason": "The server implementation is functionally correct and handles edge cases well. The only issues reported were due to placeholder resolution failures in the test runner, not the server itself. To improve compatibility and simplify client-side handling, I have modified the `search_photos` tool to return a native dictionary/json object instead of a JSON string.",
  "refined_code": "import sys\nimport os\nimport httpx\nimport json\nfrom mcp.server.fastmcp import FastMCP\nimport asyncio\n\n# 初始化 FastMCP 服务器\nmcp = FastMCP(\"mcp_unsplash_photo_searcher\")\n\n# 设置代理（如需要）\nos.environ['HTTP_PROXY'] = 'http://127.0.0.1:7890'\nos.environ['HTTPS_PROXY'] = 'http://127.0.0.1:7890'\n\n# 从环境变量获取 Unsplash Access Key\nUNSPLASH_ACCESS_KEY = os.environ.get('UNSPLASH_ACCESS_KEY', \"URla9S3DiHRJJT1zWCn1RxQfUuB2irCq2xiGzj5wlq0\")\nif not UNSPLASH_ACCESS_KEY:\n    raise ValueError(\"UNSPLASH_ACCESS_KEY 环境变量未设置\")\n\n# 创建异步 HTTP 客户端\nclient = httpx.AsyncClient(\n    base_url=\"https://api.unsplash.com\",\n    headers={\n        \"Authorization\": f\"Client-ID {UNSPLASH_ACCESS_KEY}\",\n        \"User-Agent\": \"unsplash-photo-searcher/1.0\"\n    },\n    timeout=10.0,\n    limits=httpx.Limits(max_keepalive_connections=5, max_connections=10)\n)\n\n@mcp.tool()\nasync def search_photos(query: str, page: int = 1, per_page: int = 10,\n                        order_by: str = \"relevant\", color: str = None,\n                        orientation: str = None) -> dict:\n    \"\"\"\n    在 Unsplash 平台根据关键词、分页、排序、颜色和图片方向等条件搜索图片。\n\n    Args:\n        query (str): 搜索关键词（必填）\n        page (int): 分页编号，默认为 1\n        per_page (int): 每页结果数量，默认为 10，最大不超过 30\n        order_by (str): 排序方式：latest, oldest, relevant，默认为 relevant\n        color (str): 图片颜色过滤，如 red, blue, black 等（可选）\n        orientation (str): 图片方向：landscape, portrait, squarish（可选）\n\n    Returns:\n        dict: 包含以下字段的字典：\n            - results: 包含图片信息的列表，每项包括：\n                - id: 图片ID\n                - description: 图片描述\n                - urls: 包含不同尺寸URL的对象（raw, full, regular, small, thumb）\n                - width: 图片宽度\n                - height: 图片高度\n            - total: 总结果数\n            - page: 当前页码\n            - per_page: 每页结果数\n\n    Raises:\n        ValueError: 如果必填参数缺失或参数值无效\n        httpx.HTTPStatusError: 如果API请求失败\n    \"\"\"\n    try:\n        # 参数验证\n        if not query or not query.strip():\n            raise ValueError(\"搜索关键词不能为空\")\n        \n        if page < 1:\n            raise ValueError(\"页码必须大于等于1\")\n        \n        if per_page < 1 or per_page > 30:\n            raise ValueError(\"每页结果数量必须在1到30之间\")\n        \n        valid_order_by = [\"latest\", \"oldest\", \"relevant\"]\n        if order_by not in valid_order_by:\n            raise ValueError(f\"排序方式必须是 {', '.join(valid_order_by)} 中的一个\")\n        \n        valid_orientation = [\"landscape\", \"portrait\", \"squarish\"]\n        if orientation and orientation not in valid_orientation:\n            raise ValueError(f\"图片方向必须是 {', '.join(valid_orientation)} 中的一个或None\")\n\n        # 构建查询参数\n        params = {\n            \"query\": query,\n            \"page\": page,\n            \"per_page\": per_page,\n            \"order_by\": order_by\n        }\n        \n        if color:\n            params[\"color\"] = color\n        \n        if orientation:\n            params[\"orientation\"] = orientation\n\n        # 发起API请求，添加重试逻辑以处理限流\n        retries = 3\n        for attempt in range(retries):\n            response = await client.get(\"/search/photos\", params=params)\n            if response.status_code == 429:  # Too Many Requests\n                if attempt < retries - 1:\n                    wait_time = 2 ** attempt\n                    print(f\"收到限流响应，等待 {wait_time} 秒后重试...\")\n                    await asyncio.sleep(wait_time)\n                    continue\n            break\n        \n        response.raise_for_status()\n        \n        # 解析响应数据\n        data = response.json()\n        \n        # 构造返回结果\n        result = {\n            \"results\": [],\n            \"total\": data.get(\"total\", 0),\n            \"page\": page,\n            \"per_page\": per_page\n        }\n        \n        for item in data.get(\"results\", []):\n            photo = {\n                \"id\": item.get(\"id\"),\n                \"description\": item.get(\"description\") or item.get(\"alt_description\", \"无描述\"),\n                \"urls\": item.get(\"urls\", {}),\n                \"width\": item.get(\"width\"),\n                \"height\": item.get(\"height\")\n            }\n            result[\"results\"].append(photo)\n        \n        return result\n    \n    except httpx.HTTPStatusError as e:\n        # 处理HTTP错误\n        error_msg = f\"Unsplash API 请求失败: {e.response.status_code} - {e.response.text}\"\n        raise ValueError(error_msg) from e\n    \n    except Exception as e:\n        # 处理其他异常\n        raise ValueError(f\"搜索图片时发生错误: {str(e)}\") from e\n\nif __name__ == \"__main__\":\n    sys.stdout.reconfigure(encoding='utf-8')\n    mcp.run()"
}